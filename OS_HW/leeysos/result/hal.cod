; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\Develop\HW\leeysos\hal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `string'
;	COMDAT ??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_H'
	DB	'ardDrive() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp'
	DB	'_IRQ_MathCoprocessor() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_Mouse'
	DB	'() ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_VGA() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_C'
	DB	'MOSClock() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ DB 'Hal'
	DB	'p_IRQ_ReqFromSlave8259() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_MachineCheck() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_AlignmentCheck() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_FloatingPointError() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_P'
	DB	'ageFault() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_GeneralProtection() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_StackException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_SegmentNotPresent() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'InvalidTSS() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_CoprocessorOverrun() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_DeviceNotAvailable() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_E'
	DB	'CT_InvaildOpcode() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_BOUN'
	DB	'DS() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_INTO()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'Breakpoint() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_NMI() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_DebugException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?msg@?1??Halp_ECT_DivideByZero@@9@9 DD FLAT:??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DivideByZero'::`2'::msg
?msg@?1??Halp_ECT_DebugException@@9@9 DD FLAT:??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DebugException'::`2'::msg
?msg@?1??Halp_ECT_NMI@@9@9 DD FLAT:??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_NMI'::`2'::msg
?msg@?1??Halp_ECT_Breakpoint@@9@9 DD FLAT:??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_Breakpoint'::`2'::msg
?msg@?1??Halp_ECT_INTO@@9@9 DD FLAT:??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_INTO'::`2'::msg
?msg@?1??Halp_ECT_BOUNDS@@9@9 DD FLAT:??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_BOUNDS'::`2'::msg
?msg@?1??Halp_ECT_InvaildOpcode@@9@9 DD FLAT:??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvaildOpcode'::`2'::msg
?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9 DD FLAT:??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_DeviceNotAvailable'::`2'::msg
?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9 DD FLAT:??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_CoprocessorOverrun'::`2'::msg
?msg@?1??Halp_ECT_InvalidTSS@@9@9 DD FLAT:??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvalidTSS'::`2'::msg
?msg@?1??Halp_ECT_SegmentNotPresent@@9@9 DD FLAT:??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_SegmentNotPresent'::`2'::msg
?msg@?1??Halp_ECT_StackException@@9@9 DD FLAT:??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_StackException'::`2'::msg
?msg@?1??Halp_ECT_GeneralProtection@@9@9 DD FLAT:??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_GeneralProtection'::`2'::msg
?msg@?1??Halp_ECT_PageFault@@9@9 DD FLAT:??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_PageFault'::`2'::msg
?msg@?1??Halp_ECT_FloatingPointError@@9@9 DD FLAT:??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_FloatingPointError'::`2'::msg
?msg@?1??Halp_ECT_AlignmentCheck@@9@9 DD FLAT:??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_AlignmentCheck'::`2'::msg
?msg@?1??Halp_ECT_MachineCheck@@9@9 DD FLAT:??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_MachineCheck'::`2'::msg
?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9 DD FLAT:??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_ReqFromSlave8259'::`2'::msg
?msg@?1??Halp_IRQ_COM2@@9@9 DD FLAT:??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM2'::`2'::msg
?msg@?1??Halp_IRQ_COM1@@9@9 DD FLAT:??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM1'::`2'::msg
?msg@?1??Halp_IRQ_LPT2@@9@9 DD FLAT:??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT2'::`2'::msg
?msg@?1??Halp_IRQ_LPT1@@9@9 DD FLAT:??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT1'::`2'::msg
?msg@?1??Halp_IRQ_CMOSClock@@9@9 DD FLAT:??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_CMOSClock'::`2'::msg
?msg@?1??Halp_IRQ_VGA@@9@9 DD FLAT:??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_VGA'::`2'::msg
?msg@?1??Halp_IRQ_Mouse@@9@9 DD FLAT:??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_Mouse'::`2'::msg
?msg@?1??Halp_IRQ_MathCoprocessor@@9@9 DD FLAT:??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_MathCoprocessor'::`2'::msg
?msg@?1??Halp_IRQ_HardDrive@@9@9 DD FLAT:??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_HardDrive'::`2'::msg
	ORG $+4
_m_IntHandlers DB 00H
	DD	FLAT:_Halp_ECT_DivideByZero
	DW	08e00H
	DB	01H
	DD	FLAT:_Halp_ECT_DebugException
	DW	08e00H
	DB	02H
	DD	FLAT:_Halp_ECT_NMI
	DW	08e00H
	DB	03H
	DD	FLAT:_Halp_ECT_Breakpoint
	DW	08e00H
	DB	04H
	DD	FLAT:_Halp_ECT_INTO
	DW	08e00H
	DB	05H
	DD	FLAT:_Halp_ECT_BOUNDS
	DW	08e00H
	DB	06H
	DD	FLAT:_Halp_ECT_InvaildOpcode
	DW	08e00H
	DB	07H
	DD	FLAT:_Halp_ECT_DeviceNotAvailable
	DW	08e00H
	DB	08H
	DD	FLAT:_Halp_ECT_DoubleFault
	DW	08e00H
	DB	09H
	DD	FLAT:_Halp_ECT_CoprocessorOverrun
	DW	08e00H
	DB	0aH
	DD	FLAT:_Halp_ECT_InvalidTSS
	DW	08e00H
	DB	0bH
	DD	FLAT:_Halp_ECT_SegmentNotPresent
	DW	08e00H
	DB	0cH
	DD	FLAT:_Halp_ECT_StackException
	DW	08e00H
	DB	0dH
	DD	FLAT:_Halp_ECT_GeneralProtection
	DW	08e00H
	DB	0eH
	DD	FLAT:_Halp_ECT_PageFault
	DW	08e00H
	DB	010H
	DD	FLAT:_Halp_ECT_FloatingPointError
	DW	08e00H
	DB	011H
	DD	FLAT:_Halp_ECT_AlignmentCheck
	DW	08e00H
	DB	012H
	DD	FLAT:_Halp_ECT_MachineCheck
	DW	08e00H
	DB	021H
	DD	FLAT:_Halp_IRQ_Keyboard
	DW	08e00H
	DB	022H
	DD	FLAT:_Halp_IRQ_ReqFromSlave8259
	DW	08e00H
	DB	023H
	DD	FLAT:_Halp_IRQ_COM2
	DW	08e00H
	DB	024H
	DD	FLAT:_Halp_IRQ_COM1
	DW	08e00H
	DB	025H
	DD	FLAT:_Halp_IRQ_LPT2
	DW	08e00H
	DB	026H
	DD	FLAT:_Halp_IRQ_FloppyDisk
	DW	08e00H
	DB	027H
	DD	FLAT:_Halp_IRQ_LPT1
	DW	08e00H
	DB	028H
	DD	FLAT:_Halp_IRQ_CMOSClock
	DW	08e00H
	DB	029H
	DD	FLAT:_Halp_IRQ_VGA
	DW	08e00H
	DB	02cH
	DD	FLAT:_Halp_IRQ_Mouse
	DW	08e00H
	DB	02dH
	DD	FLAT:_Halp_IRQ_MathCoprocessor
	DW	08e00H
	DB	02eH
	DD	FLAT:_Halp_IRQ_HardDrive
	DW	08e00H
	DB	020H
	DD	038H
	DW	08500H
	DB	030H
	DD	040H
	DW	08500H
	DB	00H
	DD	00H
	DW	00H
_DATA	ENDS
;	COMDAT ??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_DivideByZero() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
PUBLIC	_HalWriteTssIntoGdt
EXTRN	_m_GdtTable:BYTE
; Function compile flags: /Odtp /ZI
; File c:\develop\hw\leeysos\hal.c
;	COMDAT _HalWriteTssIntoGdt
_TEXT	SEGMENT
_pTss32$ = 8						; size = 4
_TssSize$ = 12						; size = 4
_TssNumber$ = 16					; size = 4
_SetBusy$ = 20						; size = 4
_HalWriteTssIntoGdt PROC				; COMDAT

; 35   : BOOL HalWriteTssIntoGdt(TSS_32 *pTss32, DWORD TssSize, DWORD TssNumber, BOOL SetBusy){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 36   : 
; 37   : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 38   :    m_GdtTable[TssNumber>>3].limit_1   = (BYTE)(	TssSize & 0x000000ff);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00016	c1 e9 03	 shr	 ecx, 3
  00019	88 04 cd 00 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8], al

; 39   :    m_GdtTable[TssNumber>>3].limit_2   = (BYTE)((TssSize & 0x0000ff00) >> 8);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  00023	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00028	c1 e8 08	 shr	 eax, 8
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0002e	c1 e9 03	 shr	 ecx, 3
  00031	88 04 cd 01 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+1], al

; 40   :    m_GdtTable[TssNumber>>3].glimit_3  = (BYTE)((TssSize & 0x000f0000) >> 16);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  0003b	25 00 00 0f 00	 and	 eax, 983040		; 000f0000H
  00040	c1 e8 10	 shr	 eax, 16			; 00000010H
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00046	c1 e9 03	 shr	 ecx, 3
  00049	88 04 cd 06 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+6], al

; 41   :    m_GdtTable[TssNumber>>3].base_1    = (BYTE)((	(int)pTss32) & 0x000000ff);

  00050	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00053	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00058	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0005b	c1 e9 03	 shr	 ecx, 3
  0005e	88 04 cd 02 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+2], al

; 42   :    m_GdtTable[TssNumber>>3].base_2    = (BYTE)(((	(int)pTss32) & 0x0000ff00) >> 8);

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00068	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0006d	c1 f8 08	 sar	 eax, 8
  00070	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00073	c1 e9 03	 shr	 ecx, 3
  00076	88 04 cd 03 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+3], al

; 43   :    m_GdtTable[TssNumber>>3].base_3    = (BYTE)(((	(int)pTss32) & 0x00ff0000) >> 16);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00080	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00085	c1 f8 10	 sar	 eax, 16			; 00000010H
  00088	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0008b	c1 e9 03	 shr	 ecx, 3
  0008e	88 04 cd 04 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+4], al

; 44   :    m_GdtTable[TssNumber>>3].base_4    = (BYTE)(((	(int)pTss32) & 0xff000000) >> 24);

  00095	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00098	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0009d	c1 e8 18	 shr	 eax, 24			; 00000018H
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  000a3	c1 e9 03	 shr	 ecx, 3
  000a6	88 04 cd 07 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+7], al

; 45   :    m_GdtTable[TssNumber>>3].type      = (SetBusy ? 0x8b : 0x89);

  000ad	33 c0		 xor	 eax, eax
  000af	83 7d 14 00	 cmp	 DWORD PTR _SetBusy$[ebp], 0
  000b3	0f 95 c0	 setne	 al
  000b6	8d 84 00 89 00
	00 00		 lea	 eax, DWORD PTR [eax+eax+137]
  000bd	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  000c0	c1 e9 03	 shr	 ecx, 3
  000c3	88 04 cd 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+5], al

; 46   : EXIT_CRITICAL_SECTION();

  000ca	9d		 popfd

; 47   : 
; 48   :    return TRUE;

  000cb	b8 01 00 00 00	 mov	 eax, 1

; 49   : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_HalWriteTssIntoGdt ENDP
_TEXT	ENDS
PUBLIC	_HalSetupTaskSwitchingEnv
PUBLIC	_HalSetupTSS
EXTRN	_SysGetSyscallStackPtr:PROC
EXTRN	_SysGetSyscallStackSize:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTSS
_TEXT	SEGMENT
_stack$ = -8						; size = 4
_dwEFLAGS$ = -4						; size = 4
_pTss32$ = 8						; size = 4
_IsKernelTSS$ = 12					; size = 4
_EntryPoint$ = 16					; size = 4
_pStackBase$ = 20					; size = 4
_StackSize$ = 24					; size = 4
_HalSetupTSS PROC					; COMDAT

; 51   : BOOL HalSetupTSS(IN OUT TSS_32 *pTss32, IN BOOL IsKernelTSS, IN int EntryPoint, IN int *pStackBase, IN DWORD StackSize){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 52   :    DWORD dwEFLAGS;
; 53   :    int stack = (int)pStackBase + StackSize - 1;

  00009	8b 45 18	 mov	 eax, DWORD PTR _StackSize$[ebp]
  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pStackBase$[ebp]
  0000f	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00013	89 55 f8	 mov	 DWORD PTR _stack$[ebp], edx

; 54   : 
; 55   :    memset(pTss32, NULL, sizeof(TSS_32));

  00016	6a 68		 push	 104			; 00000068H
  00018	6a 00		 push	 0
  0001a	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 56   : 
; 57   :    _asm{
; 58   :       push      eax

  00026	50		 push	 eax

; 59   : 
; 60   :       pushfd

  00027	9c		 pushfd

; 61   :       pop         eax

  00028	58		 pop	 eax

; 62   :       or         ah, 02h      ; IF

  00029	80 cc 02	 or	 ah, 2

; 63   :       mov         dwEFLAGS, eax

  0002c	89 45 fc	 mov	 DWORD PTR _dwEFLAGS$[ebp], eax

; 64   : 
; 65   :       pop         eax

  0002f	58		 pop	 eax

; 66   :    }
; 67   : 
; 68   :    if(IsKernelTSS){

  00030	83 7d 0c 00	 cmp	 DWORD PTR _IsKernelTSS$[ebp], 0
  00034	74 1d		 je	 SHORT $LN2@HalSetupTS

; 69   :       pTss32->cs = KERNEL_CS;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00039	66 c7 40 4c 08
	00		 mov	 WORD PTR [eax+76], 8

; 70   :       pTss32->ds = KERNEL_DS;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00042	66 c7 40 54 10
	00		 mov	 WORD PTR [eax+84], 16	; 00000010H

; 71   :       pTss32->ss = KERNEL_SS;

  00048	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0004b	66 c7 40 50 10
	00		 mov	 WORD PTR [eax+80], 16	; 00000010H

; 72   :    }else{

  00051	eb 1b		 jmp	 SHORT $LN1@HalSetupTS
$LN2@HalSetupTS:

; 73   :       pTss32->cs = USER_CS;

  00053	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00056	66 c7 40 4c 1b
	00		 mov	 WORD PTR [eax+76], 27	; 0000001bH

; 74   :       pTss32->ds = USER_DS;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0005f	66 c7 40 54 23
	00		 mov	 WORD PTR [eax+84], 35	; 00000023H

; 75   :       pTss32->ss = USER_SS;

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00068	66 c7 40 50 23
	00		 mov	 WORD PTR [eax+80], 35	; 00000023H
$LN1@HalSetupTS:

; 76   :    }
; 77   :    pTss32->es = pTss32->ds;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00074	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00078	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 78   :    pTss32->fs = pTss32->ds;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00082	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00086	66 89 50 58	 mov	 WORD PTR [eax+88], dx

; 79   :    pTss32->gs = pTss32->ds;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00090	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00094	66 89 50 5c	 mov	 WORD PTR [eax+92], dx

; 80   : 
; 81   :    pTss32->eflags = dwEFLAGS;

  00098	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _dwEFLAGS$[ebp]
  0009e	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 82   :    pTss32->eip = EntryPoint;

  000a1	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000a4	8b 4d 10	 mov	 ecx, DWORD PTR _EntryPoint$[ebp]
  000a7	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 83   :    pTss32->esp = (DWORD)stack;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _stack$[ebp]
  000b0	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 84   : 
; 85   :    pTss32->ss0 = KERNEL_SS;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000b6	66 c7 40 08 10
	00		 mov	 WORD PTR [eax+8], 16	; 00000010H

; 86   :    pTss32->esp0 = ((DWORD)((BYTE*)SysGetSyscallStackPtr)+SysGetSyscallStackSize() - 1);

  000bc	e8 00 00 00 00	 call	 _SysGetSyscallStackSize
  000c1	05 00 00 00 00	 add	 eax, OFFSET _SysGetSyscallStackPtr
  000c6	83 e8 01	 sub	 eax, 1
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  000cc	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 87   : 
; 88   :    HalSetupTaskSwitchingEnv(pTss32);

  000cf	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _HalSetupTaskSwitchingEnv
  000d8	83 c4 04	 add	 esp, 4

; 89   : 
; 90   :    return TRUE;

  000db	b8 01 00 00 00	 mov	 eax, 1

; 91   : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_HalSetupTSS ENDP
_TEXT	ENDS
PUBLIC	_HalChangeTssBusyBit
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTaskSwitchingEnv
_TEXT	SEGMENT
_stack$ = -4						; size = 4
_pTss32$ = 8						; size = 4
_HalSetupTaskSwitchingEnv PROC				; COMDAT

; 93   : BOOL HalSetupTaskSwitchingEnv(TSS_32 *pTss32){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 94   :    
; 95   :    int stack;
; 96   : 
; 97   : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 98   :    stack = pTss32->esp;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0000e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00011	89 4d fc	 mov	 DWORD PTR _stack$[ebp], ecx

; 99   :    stack -= sizeof(int);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00017	83 e8 04	 sub	 eax, 4
  0001a	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 100  :    *((int*)stack) = pTss32->eflags;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00023	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 101  :    stack -= sizeof(int);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  0002b	83 e8 04	 sub	 eax, 4
  0002e	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 102  :    *((int*)stack) = pTss32->cs;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00034	0f b7 48 4c	 movzx	 ecx, WORD PTR [eax+76]
  00038	8b 55 fc	 mov	 edx, DWORD PTR _stack$[ebp]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 103  :    stack -= sizeof(int);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00040	83 e8 04	 sub	 eax, 4
  00043	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 104  :    *((int*)stack) = pTss32->eip;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  0004c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0004f	89 10		 mov	 DWORD PTR [eax], edx

; 105  :    pTss32->esp = stack;

  00051	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _stack$[ebp]
  00057	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 106  : EXIT_CRITICAL_SECTION();

  0005a	9d		 popfd

; 107  : 
; 108  :    HalChangeTssBusyBit(TASK_SW_SEG, TRUE);

  0005b	6a 01		 push	 1
  0005d	6a 28		 push	 40			; 00000028H
  0005f	e8 00 00 00 00	 call	 _HalChangeTssBusyBit
  00064	83 c4 08	 add	 esp, 8

; 109  : 
; 110  :    return TRUE;

  00067	b8 01 00 00 00	 mov	 eax, 1

; 111  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_HalSetupTaskSwitchingEnv ENDP
_TEXT	ENDS
PUBLIC	_HalSetupTaskLink
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTaskLink
_TEXT	SEGMENT
_pTss32$ = 8						; size = 4
_TaskLink$ = 12						; size = 2
_HalSetupTaskLink PROC					; COMDAT

; 113  : BOOL HalSetupTaskLink(TSS_32 *pTss32, WORD TaskLink){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :    ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 115  :    pTss32->eflags |= 0x4000;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0000e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00011	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  00017	8b 55 08	 mov	 edx, DWORD PTR _pTss32$[ebp]
  0001a	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 116  :    pTss32->prev_task_link = TaskLink;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00020	66 8b 4d 0c	 mov	 cx, WORD PTR _TaskLink$[ebp]
  00024	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :    EXIT_CRITICAL_SECTION();

  00027	9d		 popfd

; 118  :    
; 119  :    return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1

; 120  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_HalSetupTaskLink ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalChangeTssBusyBit
_TEXT	SEGMENT
_TssSeg$ = 8						; size = 2
_SetBit$ = 12						; size = 4
_HalChangeTssBusyBit PROC				; COMDAT

; 122  : VOID HalChangeTssBusyBit(WORD TssSeg, BOOL SetBit){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 123  :    ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 124  : 
; 125  :    if(SetBit){

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _SetBit$[ebp], 0
  0000f	74 22		 je	 SHORT $LN2@HalChangeT

; 126  :       m_GdtTable[TssSeg>>3].type |=0x02;

  00011	0f b7 45 08	 movzx	 eax, WORD PTR _TssSeg$[ebp]
  00015	c1 f8 03	 sar	 eax, 3
  00018	0f b6 0c c5 05
	00 00 00	 movzx	 ecx, BYTE PTR _m_GdtTable[eax*8+5]
  00020	83 c9 02	 or	 ecx, 2
  00023	0f b7 55 08	 movzx	 edx, WORD PTR _TssSeg$[ebp]
  00027	c1 fa 03	 sar	 edx, 3
  0002a	88 0c d5 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[edx*8+5], cl

; 127  :    }else{

  00031	eb 23		 jmp	 SHORT $LN1@HalChangeT
$LN2@HalChangeT:

; 128  :       m_GdtTable[TssSeg>>3].type &= 0xfd;

  00033	0f b7 45 08	 movzx	 eax, WORD PTR _TssSeg$[ebp]
  00037	c1 f8 03	 sar	 eax, 3
  0003a	0f b6 0c c5 05
	00 00 00	 movzx	 ecx, BYTE PTR _m_GdtTable[eax*8+5]
  00042	81 e1 fd 00 00
	00		 and	 ecx, 253		; 000000fdH
  00048	0f b7 55 08	 movzx	 edx, WORD PTR _TssSeg$[ebp]
  0004c	c1 fa 03	 sar	 edx, 3
  0004f	88 0c d5 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[edx*8+5], cl
$LN1@HalChangeT:

; 129  :    }
; 130  :    EXIT_CRITICAL_SECTION();

  00056	9d		 popfd

; 131  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_HalChangeTssBusyBit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ ; `string'
PUBLIC	_HalInitializeHal
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
CONST	SEGMENT
??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ DB 'HalpIniti'
	DB	'alizeProcessor() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalInitializeHal
_TEXT	SEGMENT
_HalInitializeHal PROC					; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 139  :    //실질적인 하드웨어 초기화 함수 호출
; 140  :    if(!HalpInitializeProcessor()) {

  00009	e8 00 00 00 00	 call	 _HalpInitializeProcessor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN1@HalInitial

; 141  :       DbgPrint("HalpInitializeProcessor() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 142  :       return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 05		 jmp	 SHORT $LN2@HalInitial
$LN1@HalInitial:

; 143  :    }
; 144  : 
; 145  :    return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
$LN2@HalInitial:

; 146  : 
; 147  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_HalInitializeHal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@LJLJPIMA@Interrupt?5Service?5is?5installed?$CB?$CB@ ; `string'
PUBLIC	??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ ; `string'
PUBLIC	??_C@_0BC@JACIBMKF@PIC?5is?5success?$CB?$CB?5?$AA@ ; `string'
PUBLIC	??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ ; `string'
PUBLIC	??_C@_0BH@JIPOFIMD@A20?5line?5is?5success?$CB?$CB?5?$AA@ ; `string'
PUBLIC	??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ ; `string'
;	COMDAT ??_C@_0CC@LJLJPIMA@Interrupt?5Service?5is?5installed?$CB?$CB@
CONST	SEGMENT
??_C@_0CC@LJLJPIMA@Interrupt?5Service?5is?5installed?$CB?$CB@ DB 'Interru'
	DB	'pt Service is installed!! ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ DB 'HalpStar'
	DB	'tIntService() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ DB 'Sy'
	DB	'stemTimer is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
CONST	SEGMENT
??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ DB 'HalpIni'
	DB	'tSysTimer() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JACIBMKF@PIC?5is?5success?$CB?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BC@JACIBMKF@PIC?5is?5success?$CB?$CB?5?$AA@ DB 'PIC is success!! ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
CONST	SEGMENT
??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ DB 'HalpIn'
	DB	'itPIC() returned an error.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JIPOFIMD@A20?5line?5is?5success?$CB?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BH@JIPOFIMD@A20?5line?5is?5success?$CB?$CB?5?$AA@ DB 'A20 line is '
	DB	'success!! ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
CONST	SEGMENT
??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ DB 'HalpEna'
	DB	'bleA20() returned an error.', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalpInitializeProcessor
_TEXT	SEGMENT
_HalpInitializeProcessor PROC				; COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 152  :    //A20 Line 활성화 함수
; 153  :    if(!HalpEnableA20()) {

  00009	e8 00 00 00 00	 call	 _HalpEnableA20
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN4@HalpInitia

; 154  :       DbgPrint("HalpEnableA20() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 155  :       return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 8c 00 00 00	 jmp	 $LN5@HalpInitia
$LN4@HalpInitia:

; 156  :    }
; 157  :    DbgPrint("A20 line is success!! ");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JIPOFIMD@A20?5line?5is?5success?$CB?$CB?5?$AA@
  0002b	e8 00 00 00 00	 call	 _CrtPrintf
  00030	83 c4 04	 add	 esp, 4

; 158  : 
; 159  :    //PIC 초기화 함수
; 160  :    if(!HalpInitPIC()) {

  00033	e8 00 00 00 00	 call	 _HalpInitPIC
  00038	85 c0		 test	 eax, eax
  0003a	75 11		 jne	 SHORT $LN3@HalpInitia

; 161  :       DbgPrint("HalpInitPIC() returned an error.\r\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
  00041	e8 00 00 00 00	 call	 _CrtPrintf
  00046	83 c4 04	 add	 esp, 4

; 162  :       return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 65		 jmp	 SHORT $LN5@HalpInitia
$LN3@HalpInitia:

; 163  :    }
; 164  :    DbgPrint("PIC is success!! ");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JACIBMKF@PIC?5is?5success?$CB?$CB?5?$AA@
  00052	e8 00 00 00 00	 call	 _CrtPrintf
  00057	83 c4 04	 add	 esp, 4

; 165  : 
; 166  :    //TIMER 초기화 함수
; 167  :    if(!HalpInitSysTimer(TIMEOUT_PER_SECOND)) {

  0005a	6a 32		 push	 50			; 00000032H
  0005c	e8 00 00 00 00	 call	 _HalpInitSysTimer
  00061	83 c4 04	 add	 esp, 4
  00064	85 c0		 test	 eax, eax
  00066	75 11		 jne	 SHORT $LN2@HalpInitia

; 168  :       DbgPrint("HalpInitSysTimer() returned an error.\r\n");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
  0006d	e8 00 00 00 00	 call	 _CrtPrintf
  00072	83 c4 04	 add	 esp, 4

; 169  :       return FALSE;

  00075	33 c0		 xor	 eax, eax
  00077	eb 39		 jmp	 SHORT $LN5@HalpInitia
$LN2@HalpInitia:

; 170  :    }
; 171  :    DbgPrint("SystemTimer is initialized!!\r\n");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
  0007e	e8 00 00 00 00	 call	 _CrtPrintf
  00083	83 c4 04	 add	 esp, 4

; 172  : 
; 173  :    //INTERRUPT 초기화 함수 
; 174  :    if(!HalpStartIntService()) {

  00086	e8 00 00 00 00	 call	 _HalpStartIntService
  0008b	85 c0		 test	 eax, eax
  0008d	75 11		 jne	 SHORT $LN1@HalpInitia

; 175  :       DbgPrint("HalpStartIntService() returned an error.\r\n");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
  00094	e8 00 00 00 00	 call	 _CrtPrintf
  00099	83 c4 04	 add	 esp, 4

; 176  :       return FALSE;

  0009c	33 c0		 xor	 eax, eax
  0009e	eb 12		 jmp	 SHORT $LN5@HalpInitia
$LN1@HalpInitia:

; 177  :    }
; 178  :    DbgPrint("Interrupt Service is installed!! ");

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LJLJPIMA@Interrupt?5Service?5is?5installed?$CB?$CB@
  000a5	e8 00 00 00 00	 call	 _CrtPrintf
  000aa	83 c4 04	 add	 esp, 4

; 179  : 
; 180  : 
; 181  :    return TRUE;

  000ad	b8 01 00 00 00	 mov	 eax, 1
$LN5@HalpInitia:

; 182  : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_HalpInitializeProcessor ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalpEnableA20
_TEXT	SEGMENT
_flag$ = -18						; size = 1
_status$ = -17						; size = 1
_test_2_buf$ = -16					; size = 4
_test_2$ = -12						; size = 4
_test_1_buf$ = -8					; size = 4
_test_1$ = -4						; size = 4
_HalpEnableA20 PROC					; COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 185  :    int *test_1 = (int *)0x00000000, test_1_buf;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _test_1$[ebp], 0

; 186  :    int *test_2 = (int *)0x00100000, test_2_buf;

  00010	c7 45 f4 00 00
	10 00		 mov	 DWORD PTR _test_2$[ebp], 1048576 ; 00100000H
$LN16@HalpEnable:

; 187  :    UCHAR status, flag;
; 188  : 
; 189  :    //Status Register(0x64)를 읽어서 입력 버퍼에 데이터가 없을 때까지 대기.
; 190  :    do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00017	6a 64		 push	 100			; 00000064H
  00019	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  0001e	83 c4 04	 add	 esp, 4
  00021	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 191  :    while( status & 0x02 );

  00024	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  00028	83 e0 02	 and	 eax, 2
  0002b	75 ea		 jne	 SHORT $LN16@HalpEnable

; 192  :    //Control Register에 데이터를 쓰는 과정
; 193  :    //output port에서 데이터를 읽어서 출력 버퍼(0x60)에 데이터를 저장하라는 명령.
; 194  :       WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd0);

  0002d	68 d0 00 00 00	 push	 208			; 000000d0H
  00032	6a 64		 push	 100			; 00000064H
  00034	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00039	83 c4 08	 add	 esp, 8
$LN13@HalpEnable:

; 195  : 
; 196  :    //Status Register(Ox64)를 읽어서 출력 버퍼(Ox60)에 데이터가 들어올때 까지 대기.
; 197  :    do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  0003c	6a 64		 push	 100			; 00000064H
  0003e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00043	83 c4 04	 add	 esp, 4
  00046	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 198  :    while( !(status&0x01) );

  00049	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 ea		 je	 SHORT $LN13@HalpEnable

; 199  :    //출력 버퍼(Ox60)에서 데이터를 읽은 후에 A20 GATE(두 번째 비트)활성화    
; 200  :    flag = READ_PORT_UCHAR((PUCHAR)0x60);

  00052	6a 60		 push	 96			; 00000060H
  00054	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00059	83 c4 04	 add	 esp, 4
  0005c	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al

; 201  :    flag |= 0x02; // A20 line 활성화

  0005f	0f b6 45 ee	 movzx	 eax, BYTE PTR _flag$[ebp]
  00063	83 c8 02	 or	 eax, 2
  00066	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al
$LN10@HalpEnable:

; 202  : 
; 203  :    //flag값을 Register에 써넣어 A20 활성화
; 204  :    do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00069	6a 64		 push	 100			; 00000064H
  0006b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00070	83 c4 04	 add	 esp, 4
  00073	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 205  :    while( status & 0x02 );

  00076	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0007a	83 e0 02	 and	 eax, 2
  0007d	75 ea		 jne	 SHORT $LN10@HalpEnable

; 206  :    WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd1);

  0007f	68 d1 00 00 00	 push	 209			; 000000d1H
  00084	6a 64		 push	 100			; 00000064H
  00086	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008b	83 c4 08	 add	 esp, 8
$LN7@HalpEnable:

; 207  : 
; 208  :    do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  0008e	6a 64		 push	 100			; 00000064H
  00090	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00095	83 c4 04	 add	 esp, 4
  00098	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 209  :    while( status & 0x02 );

  0009b	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0009f	83 e0 02	 and	 eax, 2
  000a2	75 ea		 jne	 SHORT $LN7@HalpEnable

; 210  :    WRITE_PORT_UCHAR((PUCHAR)0x60, flag); 

  000a4	8a 45 ee	 mov	 al, BYTE PTR _flag$[ebp]
  000a7	50		 push	 eax
  000a8	6a 60		 push	 96			; 00000060H
  000aa	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  000af	83 c4 08	 add	 esp, 8
$LN4@HalpEnable:

; 211  : 
; 212  :    do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  000b2	6a 64		 push	 100			; 00000064H
  000b4	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  000b9	83 c4 04	 add	 esp, 4
  000bc	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 213  :    while( status & 0x02 );

  000bf	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  000c3	83 e0 02	 and	 eax, 2
  000c6	75 ea		 jne	 SHORT $LN4@HalpEnable

; 214  : 
; 215  :    //Test A20 line
; 216  :    test_1_buf = *test_1;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 4d f8	 mov	 DWORD PTR _test_1_buf$[ebp], ecx

; 217  :    test_2_buf = *test_2;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	89 4d f0	 mov	 DWORD PTR _test_2_buf$[ebp], ecx

; 218  :    *test_1 = 0xff00ccaa;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000db	c7 00 aa cc 00
	ff		 mov	 DWORD PTR [eax], -16724822 ; ff00ccaaH

; 219  :    *test_2 = 0x22cc11dd;

  000e1	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000e4	c7 00 dd 11 cc
	22		 mov	 DWORD PTR [eax], 583799261 ; 22cc11ddH

; 220  :    if(*test_1 == *test_2) {

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR _test_2$[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000f4	75 0c		 jne	 SHORT $LN1@HalpEnable

; 221  :       *test_1 = test_1_buf;

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  000fc	89 08		 mov	 DWORD PTR [eax], ecx

; 222  :       return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 15		 jmp	 SHORT $LN17@HalpEnable
$LN1@HalpEnable:

; 223  :    }
; 224  :    //A20 line이 활성화 되었다면, test_1과 test_2의 값이 달라야 한다.
; 225  :    *test_1 = test_1_buf;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  00105	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  00108	89 08		 mov	 DWORD PTR [eax], ecx

; 226  :    *test_2 = test_2_buf;

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR _test_2_buf$[ebp]
  00110	89 08		 mov	 DWORD PTR [eax], ecx

; 227  : 
; 228  :    return TRUE;

  00112	b8 01 00 00 00	 mov	 eax, 1
$LN17@HalpEnable:

; 229  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_HalpEnableA20 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitPIC
_TEXT	SEGMENT
_HalpInitPIC PROC					; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 240  :    // Master PIC
; 241  :    WRITE_PORT_UCHAR((PUCHAR)0x20, 0x11); //ICW1 : Cascade mode, ICW4 

  00009	6a 11		 push	 17			; 00000011H
  0000b	6a 20		 push	 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00012	83 c4 08	 add	 esp, 8

; 242  :    WRITE_PORT_UCHAR((PUCHAR)0x21, 0x20); //ICW2 : 인터럽트 시작 값 INT vector 20h 

  00015	6a 20		 push	 32			; 00000020H
  00017	6a 21		 push	 33			; 00000021H
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 243  :    WRITE_PORT_UCHAR((PUCHAR)0x21, 0x04); //ICW3  

  00021	6a 04		 push	 4
  00023	6a 21		 push	 33			; 00000021H
  00025	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002a	83 c4 08	 add	 esp, 8

; 244  :    WRITE_PORT_UCHAR((PUCHAR)0x21, 0x01); //ICW4 

  0002d	6a 01		 push	 1
  0002f	6a 21		 push	 33			; 00000021H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 245  :    WRITE_PORT_UCHAR((PUCHAR)0x21, 0x00);

  00039	6a 00		 push	 0
  0003b	6a 21		 push	 33			; 00000021H
  0003d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00042	83 c4 08	 add	 esp, 8

; 246  : 
; 247  :    // Slave PIC 
; 248  :    WRITE_PORT_UCHAR((PUCHAR)0xa0, 0x11); //ICW1 : Cascade mode, ICW4 

  00045	6a 11		 push	 17			; 00000011H
  00047	68 a0 00 00 00	 push	 160			; 000000a0H
  0004c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00051	83 c4 08	 add	 esp, 8

; 249  :    WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x28); //ICW2 : 인터럽트 시작 값 INT vector 28h 

  00054	6a 28		 push	 40			; 00000028H
  00056	68 a1 00 00 00	 push	 161			; 000000a1H
  0005b	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00060	83 c4 08	 add	 esp, 8

; 250  :    WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x02); //ICW3  

  00063	6a 02		 push	 2
  00065	68 a1 00 00 00	 push	 161			; 000000a1H
  0006a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0006f	83 c4 08	 add	 esp, 8

; 251  :    WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x01); //ICW4 

  00072	6a 01		 push	 1
  00074	68 a1 00 00 00	 push	 161			; 000000a1H
  00079	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007e	83 c4 08	 add	 esp, 8

; 252  :    WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x00);

  00081	6a 00		 push	 0
  00083	68 a1 00 00 00	 push	 161			; 000000a1H
  00088	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008d	83 c4 08	 add	 esp, 8

; 253  : 
; 254  :    return TRUE;

  00090	b8 01 00 00 00	 mov	 eax, 1

; 255  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_HalpInitPIC ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitSysTimer
_TEXT	SEGMENT
_timeout$ = -4						; size = 2
_timeoutPerSecond$ = 8					; size = 1
_HalpInitSysTimer PROC					; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 259  :    //새로운 counter 값 입력
; 260  :    WORD timeout = (WORD)(1193180/timeoutPerSecond);

  00009	0f b6 4d 08	 movzx	 ecx, BYTE PTR _timeoutPerSecond$[ebp]
  0000d	b8 dc 34 12 00	 mov	 eax, 1193180		; 001234dcH
  00012	99		 cdq
  00013	f7 f9		 idiv	 ecx
  00015	66 89 45 fc	 mov	 WORD PTR _timeout$[ebp], ax

; 261  : 
; 262  :    WRITE_PORT_UCHAR((PUCHAR)0x43, 0x34);

  00019	6a 34		 push	 52			; 00000034H
  0001b	6a 43		 push	 67			; 00000043H
  0001d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00022	83 c4 08	 add	 esp, 8

; 263  : 
; 264  :    //COUNTER 0 Register의 Low, High byte 값 설정
; 265  :    WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout & 0xff));

  00025	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  00029	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002e	50		 push	 eax
  0002f	6a 40		 push	 64			; 00000040H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 266  :    WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout >> 8));

  00039	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  0003d	c1 f8 08	 sar	 eax, 8
  00040	50		 push	 eax
  00041	6a 40		 push	 64			; 00000040H
  00043	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00048	83 c4 08	 add	 esp, 8

; 267  : 
; 268  :    return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 269  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_HalpInitSysTimer ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DivideByZero
_TEXT	SEGMENT
_Halp_ECT_DivideByZero PROC				; COMDAT

; 275  :    static char *msg = "Halp_ECT_DivideByZero() \r\n";
; 276  :    _asm {
; 277  :       pushad

  00000	60		 pushad

; 278  : 
; 279  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DivideByZero@@9@9

; 280  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 281  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 282  : 
; 283  :       popad

  0000f	61		 popad

; 284  :       iretd

  00010	cf		 iretd
_Halp_ECT_DivideByZero ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DebugException
_TEXT	SEGMENT
_Halp_ECT_DebugException PROC				; COMDAT

; 290  :    static char *msg = "Halp_ECT_DebugException() \r\n";
; 291  :    _asm {
; 292  :       pushad

  00000	60		 pushad

; 293  : 
; 294  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DebugException@@9@9

; 295  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 296  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 297  : 
; 298  :       popad

  0000f	61		 popad

; 299  :       iretd

  00010	cf		 iretd
_Halp_ECT_DebugException ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_NMI
_TEXT	SEGMENT
_Halp_ECT_NMI PROC					; COMDAT

; 305  :    static char *msg = "Halp_ECT_NMI() \r\n";
; 306  :    _asm {
; 307  :       pushad

  00000	60		 pushad

; 308  : 
; 309  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_NMI@@9@9

; 310  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 311  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 312  : 
; 313  :       popad

  0000f	61		 popad

; 314  :       iretd

  00010	cf		 iretd
_Halp_ECT_NMI ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@DCILFBIK@bp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_Breakpoint@@9@9 DD 01H DUP (?)	; `Halp_ECT_Breakpoint'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0BL@DCILFBIK@bp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@DCILFBIK@bp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@ DB 'b'
	DB	'p, #1:%x, #2:%x, #3:%x ', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_Breakpoint
_TEXT	SEGMENT
_Halp_ECT_Breakpoint PROC				; COMDAT

; 320  :    static char *msg = "Halp_ECT_Breakpoint() \r\n";
; 321  :    static int dwESP;
; 322  :    _asm {
; 323  :       cli

  00000	fa		 cli

; 324  :       mov   dwESP, esp

  00001	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9, esp

; 325  :       pushad

  00007	60		 pushad

; 326  :    }
; 327  : 
; 328  :    DbgPrint("bp, #1:%x, #2:%x, #3:%x \r\n", *((int *)dwESP), *((int *)dwESP+1), *((int *)dwESP+2));

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  0000d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00010	51		 push	 ecx
  00011	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	50		 push	 eax
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	52		 push	 edx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DCILFBIK@bp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@
  00029	e8 00 00 00 00	 call	 _CrtPrintf
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@Halp_ECT_B:

; 329  :    while(1) ;

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	74 02		 je	 SHORT $LN1@Halp_ECT_B
  0003a	eb f5		 jmp	 SHORT $LN2@Halp_ECT_B
$LN1@Halp_ECT_B:

; 330  : 
; 331  :    _asm {
; 332  :       popad

  0003c	61		 popad

; 333  :       iretd

  0003d	cf		 iretd
_Halp_ECT_Breakpoint ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_INTO
_TEXT	SEGMENT
_Halp_ECT_INTO PROC					; COMDAT

; 339  :    static char *msg = "Halp_ECT_INTO() \r\n";
; 340  :    _asm {
; 341  :       pushad

  00000	60		 pushad

; 342  : 
; 343  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_INTO@@9@9

; 344  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 345  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 346  : 
; 347  :       popad

  0000f	61		 popad

; 348  :       iretd

  00010	cf		 iretd
_Halp_ECT_INTO ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_BOUNDS
_TEXT	SEGMENT
_Halp_ECT_BOUNDS PROC					; COMDAT

; 354  :    static char *msg = "Halp_ECT_BOUNDS() \r\n";
; 355  :    _asm {
; 356  :       pushad

  00000	60		 pushad

; 357  : 
; 358  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_BOUNDS@@9@9

; 359  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 360  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 361  : 
; 362  :       popad

  0000f	61		 popad

; 363  :       iretd

  00010	cf		 iretd
_Halp_ECT_BOUNDS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvaildOpcode
_TEXT	SEGMENT
_Halp_ECT_InvaildOpcode PROC				; COMDAT

; 369  :    static char *msg = "Halp_ECT_InvaildOpcode() \r\n";
; 370  :    _asm {
; 371  :       pushad

  00000	60		 pushad

; 372  : 
; 373  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvaildOpcode@@9@9

; 374  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 375  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4
$infinate$1095:

; 376  : 
; 377  : infinate:
; 378  :       jmp      infinate

  0000f	eb fe		 jmp	 SHORT $infinate$1095

; 379  : 
; 380  :       popad

  00011	61		 popad

; 381  :       iretd

  00012	cf		 iretd
_Halp_ECT_InvaildOpcode ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DeviceNotAvailable
_TEXT	SEGMENT
_Halp_ECT_DeviceNotAvailable PROC			; COMDAT

; 387  :    static char *msg = "Halp_ECT_DeviceNotAvailable() \r\n";
; 388  :    _asm {
; 389  :       pushad

  00000	60		 pushad

; 390  : 
; 391  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9

; 392  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 393  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 394  : 
; 395  :       popad

  0000f	61		 popad

; 396  :       iretd

  00010	cf		 iretd
_Halp_ECT_DeviceNotAvailable ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DoubleFault
_TEXT	SEGMENT
_Halp_ECT_DoubleFault PROC				; COMDAT

; 402  :    _asm {
; 403  :       mov      ebx, 0b8000h

  00000	bb 00 80 0b 00	 mov	 ebx, 753664		; 000b8000H

; 404  :       mov      ecx, 80*25

  00005	b9 d0 07 00 00	 mov	 ecx, 2000		; 000007d0H
$fault_loop$1105:

; 405  : 
; 406  : fault_loop:
; 407  :       mov      byte ptr [ebx], '#'

  0000a	c6 03 23	 mov	 BYTE PTR [ebx], 35	; 00000023H

; 408  :       mov      byte ptr [ebx+1], 7

  0000d	c6 43 01 07	 mov	 BYTE PTR [ebx+1], 7

; 409  :       add      ebx, 2

  00011	83 c3 02	 add	 ebx, 2

; 410  :       loop   fault_loop

  00014	e2 f4		 loop	 $fault_loop$1105
$infinate$1106:

; 411  : 
; 412  : infinate:
; 413  :       jmp      infinate

  00016	eb fe		 jmp	 SHORT $infinate$1106
_Halp_ECT_DoubleFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_CoprocessorOverrun
_TEXT	SEGMENT
_Halp_ECT_CoprocessorOverrun PROC			; COMDAT

; 419  :    static char *msg = "Halp_ECT_CoprocessorOverrun() \r\n";
; 420  :    _asm {
; 421  :       pushad

  00000	60		 pushad

; 422  : 
; 423  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9

; 424  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 425  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 426  : 
; 427  :       popad

  0000f	61		 popad

; 428  :       iretd

  00010	cf		 iretd
_Halp_ECT_CoprocessorOverrun ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvalidTSS
_TEXT	SEGMENT
_Halp_ECT_InvalidTSS PROC				; COMDAT

; 434  :    static char *msg = "Halp_ECT_InvalidTSS() \r\n";
; 435  :    _asm {
; 436  :       pushad

  00000	60		 pushad

; 437  : 
; 438  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvalidTSS@@9@9

; 439  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 440  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 441  : 
; 442  :       popad

  0000f	61		 popad

; 443  :       iretd

  00010	cf		 iretd
_Halp_ECT_InvalidTSS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_SegmentNotPresent
_TEXT	SEGMENT
_Halp_ECT_SegmentNotPresent PROC			; COMDAT

; 449  :    static char *msg = "Halp_ECT_SegmentNotPresent() \r\n";
; 450  :    _asm {
; 451  :       pushad

  00000	60		 pushad

; 452  : 
; 453  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_SegmentNotPresent@@9@9

; 454  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 455  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 456  : 
; 457  :       popad

  0000f	61		 popad

; 458  :       iretd

  00010	cf		 iretd
_Halp_ECT_SegmentNotPresent ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_StackException
_TEXT	SEGMENT
_Halp_ECT_StackException PROC				; COMDAT

; 464  :    static char *msg = "Halp_ECT_StackException() \r\n";
; 465  :    _asm {
; 466  :       pushad

  00000	60		 pushad

; 467  : 
; 468  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_StackException@@9@9

; 469  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 470  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 471  : 
; 472  :       popad

  0000f	61		 popad

; 473  :       iretd

  00010	cf		 iretd
_Halp_ECT_StackException ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@DNEGCBIO@gp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_GeneralProtection@@9@9 DD 01H DUP (?) ; `Halp_ECT_GeneralProtection'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0BL@DNEGCBIO@gp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@DNEGCBIO@gp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@ DB 'g'
	DB	'p, #1:%x, #2:%x, #3:%x ', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_GeneralProtection
_TEXT	SEGMENT
_Halp_ECT_GeneralProtection PROC			; COMDAT

; 479  :    static char *msg = "Halp_ECT_GeneralProtection() \r\n";
; 480  :    static int dwESP;
; 481  :    _asm {
; 482  :       mov      dwESP, esp

  00000	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9, esp

; 483  :       pushad

  00006	60		 pushad

; 484  : 
; 485  :       push   msg

  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_GeneralProtection@@9@9

; 486  :       call   CrtPrintf

  0000d	e8 00 00 00 00	 call	 _CrtPrintf

; 487  :       add      esp, 4

  00012	83 c4 04	 add	 esp, 4

; 488  :    }
; 489  : 
; 490  :    DbgPrint("gp, #1:%x, #2:%x, #3:%x \r\n", *((int *)dwESP+0), *((int *)dwESP+1), *((int *)dwESP+2));

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	51		 push	 ecx
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	50		 push	 eax
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DNEGCBIO@gp?0?5?$CD1?3?$CFx?0?5?$CD2?3?$CFx?0?5?$CD3?3?$CFx?5?$AN?6?$AA@
  00036	e8 00 00 00 00	 call	 _CrtPrintf
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
$infinate$1143:

; 491  : 
; 492  :    _asm {
; 493  : infinate:
; 494  :       jmp      infinate

  0003e	eb fe		 jmp	 SHORT $infinate$1143

; 495  : 
; 496  :       popad

  00040	61		 popad

; 497  :       iretd

  00041	cf		 iretd
_Halp_ECT_GeneralProtection ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_PageFault
_TEXT	SEGMENT
_Halp_ECT_PageFault PROC				; COMDAT

; 503  :    static char *msg = "Halp_ECT_PageFault() \r\n";
; 504  :    _asm {
; 505  :       pushad

  00000	60		 pushad

; 506  : 
; 507  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_PageFault@@9@9

; 508  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 509  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 510  : 
; 511  :       popad

  0000f	61		 popad

; 512  :       iretd

  00010	cf		 iretd
_Halp_ECT_PageFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_FloatingPointError
_TEXT	SEGMENT
_Halp_ECT_FloatingPointError PROC			; COMDAT

; 518  :    static char *msg = "Halp_ECT_FloatingPointError() \r\n";
; 519  :    _asm {
; 520  :       pushad

  00000	60		 pushad

; 521  : 
; 522  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_FloatingPointError@@9@9

; 523  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 524  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 525  : 
; 526  :       popad

  0000f	61		 popad

; 527  :       iretd

  00010	cf		 iretd
_Halp_ECT_FloatingPointError ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_AlignmentCheck
_TEXT	SEGMENT
_Halp_ECT_AlignmentCheck PROC				; COMDAT

; 533  :    static char *msg = "Halp_ECT_AlignmentCheck() \r\n";
; 534  :    _asm {
; 535  :       pushad

  00000	60		 pushad

; 536  : 
; 537  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_AlignmentCheck@@9@9

; 538  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 539  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 540  : 
; 541  :       popad

  0000f	61		 popad

; 542  :       iretd

  00010	cf		 iretd
_Halp_ECT_AlignmentCheck ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_MachineCheck
_TEXT	SEGMENT
_Halp_ECT_MachineCheck PROC				; COMDAT

; 548  :    static char *msg = "Halp_ECT_MachineCheck() \r\n";
; 549  :    _asm {
; 550  :       pushad

  00000	60		 pushad

; 551  : 
; 552  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_MachineCheck@@9@9

; 553  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 554  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 555  : 
; 556  :       popad

  0000f	61		 popad

; 557  :       iretd

  00010	cf		 iretd
_Halp_ECT_MachineCheck ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_Keyboard
_TEXT	SEGMENT
_Halp_IRQ_Keyboard PROC					; COMDAT

; 566  :    _asm {
; 567  :       pushad

  00000	60		 pushad

; 568  :       pushfd

  00001	9c		 pushfd

; 569  : 
; 570  :       push   ds

  00002	1e		 push	 ds

; 571  :       push   es

  00003	06		 push	 es

; 572  :       push   fs

  00004	0f a0		 push	 fs

; 573  :       push   gs

  00006	0f a8		 push	 gs

; 574  : 
; 575  :       mov      ax, KERNEL_DS      ; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 576  :       mov      ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 577  :       mov      es, ax

  0000f	66 8e c0	 mov	 es, ax

; 578  :       mov      fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 579  :       mov      gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 580  :    } 
; 581  : 
; 582  :    WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  00018	6a 20		 push	 32			; 00000020H
  0001a	6a 20		 push	 32			; 00000020H
  0001c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00021	83 c4 08	 add	 esp, 8

; 583  : 
; 584  :    _asm {
; 585  :       pop      gs

  00024	0f a9		 pop	 gs

; 586  :       pop      fs

  00026	0f a1		 pop	 fs

; 587  :       pop      es

  00028	07		 pop	 es

; 588  :       pop      ds

  00029	1f		 pop	 ds

; 589  : 
; 590  :       popfd

  0002a	9d		 popfd

; 591  :       popad

  0002b	61		 popad

; 592  :       iretd

  0002c	cf		 iretd
_Halp_IRQ_Keyboard ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_ReqFromSlave8259
_TEXT	SEGMENT
_Halp_IRQ_ReqFromSlave8259 PROC				; COMDAT

; 598  :    static char *msg = "Halp_IRQ_ReqFromSlave8259() \r\n";
; 599  :    _asm {
; 600  :       pushad

  00000	60		 pushad

; 601  : 
; 602  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9

; 603  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 604  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 605  : 
; 606  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 607  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 608  : 
; 609  :       popad

  00013	61		 popad

; 610  :       iretd

  00014	cf		 iretd
_Halp_IRQ_ReqFromSlave8259 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM2
_TEXT	SEGMENT
_Halp_IRQ_COM2 PROC					; COMDAT

; 616  :    static char *msg = "Halp_IRQ_COM2() \r\n";
; 617  :    _asm {
; 618  :       pushad

  00000	60		 pushad

; 619  : 
; 620  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM2@@9@9

; 621  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 622  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 623  : 
; 624  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 625  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 626  : 
; 627  :       popad

  00013	61		 popad

; 628  :       iretd

  00014	cf		 iretd
_Halp_IRQ_COM2 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM1
_TEXT	SEGMENT
_Halp_IRQ_COM1 PROC					; COMDAT

; 634  :    static char *msg = "Halp_IRQ_COM1() \r\n";
; 635  :    _asm {
; 636  :       pushad

  00000	60		 pushad

; 637  : 
; 638  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM1@@9@9

; 639  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 640  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 641  : 
; 642  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 643  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 644  : 
; 645  :       popad

  00013	61		 popad

; 646  :       iretd

  00014	cf		 iretd
_Halp_IRQ_COM1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT2
_TEXT	SEGMENT
_Halp_IRQ_LPT2 PROC					; COMDAT

; 652  :    static char *msg = "Halp_IRQ_LPT2() \r\n";
; 653  :    _asm {
; 654  :       pushad

  00000	60		 pushad

; 655  : 
; 656  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT2@@9@9

; 657  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 658  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 659  : 
; 660  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 661  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 662  : 
; 663  :       popad

  00013	61		 popad

; 664  :       iretd

  00014	cf		 iretd
_Halp_IRQ_LPT2 ENDP
_TEXT	ENDS
EXTRN	_Fdd_IRQ_Handler:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Halp_IRQ_FloppyDisk
_TEXT	SEGMENT
_Halp_IRQ_FloppyDisk PROC				; COMDAT

; 670  : 
; 671  :    _asm {
; 672  :       pushad

  00000	60		 pushad

; 673  :       pushfd

  00001	9c		 pushfd

; 674  : 
; 675  :       push   ds

  00002	1e		 push	 ds

; 676  :       push   es

  00003	06		 push	 es

; 677  :       push   fs

  00004	0f a0		 push	 fs

; 678  :       push   gs

  00006	0f a8		 push	 gs

; 679  : 
; 680  :       mov      ax, KERNEL_DS      ; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 681  :       mov      ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 682  :       mov      es, ax

  0000f	66 8e c0	 mov	 es, ax

; 683  :       mov      fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 684  :       mov      gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 685  :    }
; 686  : 
; 687  : 	Fdd_IRQ_Handler();

  00018	e8 00 00 00 00	 call	 _Fdd_IRQ_Handler

; 688  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  0001d	6a 20		 push	 32			; 00000020H
  0001f	6a 20		 push	 32			; 00000020H
  00021	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00026	83 c4 08	 add	 esp, 8

; 689  : 
; 690  : 
; 691  :    _asm {
; 692  :       pop      gs

  00029	0f a9		 pop	 gs

; 693  :       pop      fs

  0002b	0f a1		 pop	 fs

; 694  :       pop      es

  0002d	07		 pop	 es

; 695  :       pop      ds

  0002e	1f		 pop	 ds

; 696  : 
; 697  :       popfd

  0002f	9d		 popfd

; 698  :       popad

  00030	61		 popad

; 699  :       iretd

  00031	cf		 iretd
_Halp_IRQ_FloppyDisk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT1
_TEXT	SEGMENT
_Halp_IRQ_LPT1 PROC					; COMDAT

; 705  :    static char *msg = "Halp_IRQ_LPT1() \r\n";
; 706  :    _asm {
; 707  :       pushad

  00000	60		 pushad

; 708  : 
; 709  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT1@@9@9

; 710  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 711  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 712  : 
; 713  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 714  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 715  : 
; 716  :       popad

  00013	61		 popad

; 717  :       iretd

  00014	cf		 iretd
_Halp_IRQ_LPT1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_CMOSClock
_TEXT	SEGMENT
_Halp_IRQ_CMOSClock PROC				; COMDAT

; 723  :    static char *msg = "Halp_IRQ_CMOSClock() \r\n";
; 724  :    _asm {
; 725  :       pushad

  00000	60		 pushad

; 726  : 
; 727  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_CMOSClock@@9@9

; 728  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 729  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 730  : 
; 731  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 732  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 733  :       out      0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 734  : 
; 735  :       popad

  00015	61		 popad

; 736  :       iretd

  00016	cf		 iretd
_Halp_IRQ_CMOSClock ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_VGA
_TEXT	SEGMENT
_Halp_IRQ_VGA PROC					; COMDAT

; 742  :    static char *msg = "Halp_IRQ_VGA() \r\n";
; 743  :    _asm {
; 744  :       pushad

  00000	60		 pushad

; 745  : 
; 746  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_VGA@@9@9

; 747  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 748  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 749  : 
; 750  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 751  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 752  :       out      0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 753  : 
; 754  :       popad

  00015	61		 popad

; 755  :       iretd

  00016	cf		 iretd
_Halp_IRQ_VGA ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_Mouse
_TEXT	SEGMENT
_Halp_IRQ_Mouse PROC					; COMDAT

; 761  :    static char *msg = "Halp_IRQ_Mouse() \r\n";
; 762  :    _asm {
; 763  :       pushad

  00000	60		 pushad

; 764  : 
; 765  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_Mouse@@9@9

; 766  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 767  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 768  : 
; 769  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 770  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 771  :       out      0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 772  : 
; 773  :       popad

  00015	61		 popad

; 774  :       iretd

  00016	cf		 iretd
_Halp_IRQ_Mouse ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_MathCoprocessor
_TEXT	SEGMENT
_Halp_IRQ_MathCoprocessor PROC				; COMDAT

; 780  :    static char *msg = "Halp_IRQ_MathCoprocessor() \r\n";
; 781  :    _asm {
; 782  :       pushad

  00000	60		 pushad

; 783  : 
; 784  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_MathCoprocessor@@9@9

; 785  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 786  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 787  : 
; 788  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 789  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 790  :       out      0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 791  : 
; 792  :       popad

  00015	61		 popad

; 793  :       iretd

  00016	cf		 iretd
_Halp_IRQ_MathCoprocessor ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_HardDrive
_TEXT	SEGMENT
_Halp_IRQ_HardDrive PROC				; COMDAT

; 799  :    static char *msg = "Halp_IRQ_HardDrive() \r\n";
; 800  :    _asm {
; 801  :       pushad

  00000	60		 pushad

; 802  : 
; 803  :       push   msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_HardDrive@@9@9

; 804  :       call   CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 805  :       add      esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 806  : 
; 807  :       mov      al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 808  :       out      20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 809  :       out      0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 810  : 
; 811  :       popad

  00015	61		 popad

; 812  :       iretd

  00016	cf		 iretd
_Halp_IRQ_HardDrive ENDP
_TEXT	ENDS
EXTRN	_HalpEnableInterrupt:PROC
_BSS	SEGMENT
_m_IdtrDesc DF	01H DUP (?)
	ALIGN	8

_m_IdtGate DQ	040H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _HalpStartIntService
_TEXT	SEGMENT
_i$ = -4						; size = 4
_HalpStartIntService PROC				; COMDAT

; 882  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 883  :    int i;
; 884  : 
; 885  :    //메모리 초기화
; 886  :    memset(m_IdtGate, 0, MAX_IDT*sizeof(IDT_GATE));

  00009	68 00 02 00 00	 push	 512			; 00000200H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_IdtGate
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  : 
; 888  :    //IDT Table 만들기
; 889  :    for(i=0; i<MAX_IDT; i++) 

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN6@HalpStartI
$LN5@HalpStartI:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@HalpStartI:
  0002f	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00033	0f 8d 01 01 00
	00		 jge	 $LN4@HalpStartI

; 890  :    {
; 891  :       if(m_IntHandlers[i].offset == 0)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	6b c0 07	 imul	 eax, 7
  0003f	83 b8 01 00 00
	00 00		 cmp	 DWORD PTR _m_IntHandlers[eax+1], 0
  00046	75 05		 jne	 SHORT $LN3@HalpStartI

; 892  :          break;

  00048	e9 ed 00 00 00	 jmp	 $LN4@HalpStartI
$LN3@HalpStartI:

; 893  : 
; 894  :       if((m_IntHandlers[i].type & IDTC_TASKGATE) == IDTC_TASKGATE){

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00050	6b c0 07	 imul	 eax, 7
  00053	0f b7 88 05 00
	00 00		 movzx	 ecx, WORD PTR _m_IntHandlers[eax+5]
  0005a	81 e1 00 05 00
	00		 and	 ecx, 1280		; 00000500H
  00060	81 f9 00 05 00
	00		 cmp	 ecx, 1280		; 00000500H
  00066	75 49		 jne	 SHORT $LN2@HalpStartI

; 895  :          m_IdtGate[m_IntHandlers[i].number].selector = (WORD)(m_IntHandlers[i].offset);

  00068	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	6b c0 07	 imul	 eax, 7
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00071	6b c9 07	 imul	 ecx, 7
  00074	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  0007b	66 8b 80 01 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+1]
  00082	66 89 04 d5 02
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+2], ax

; 896  :          m_IdtGate[m_IntHandlers[i].number].type = m_IntHandlers[i].type;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008d	6b c0 07	 imul	 eax, 7
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00093	6b c9 07	 imul	 ecx, 7
  00096	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  0009d	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  000a4	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 897  :       }else{      

  000ac	e9 84 00 00 00	 jmp	 $LN1@HalpStartI
$LN2@HalpStartI:

; 898  :          m_IdtGate[m_IntHandlers[i].number].selector      = KERNEL_CS;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b4	6b c0 07	 imul	 eax, 7
  000b7	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_IntHandlers[eax]
  000be	66 c7 04 cd 02
	00 00 00 08 00	 mov	 WORD PTR _m_IdtGate[ecx*8+2], 8

; 899  :          m_IdtGate[m_IntHandlers[i].number].type         = m_IntHandlers[i].type;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cb	6b c0 07	 imul	 eax, 7
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d1	6b c9 07	 imul	 ecx, 7
  000d4	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  000db	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  000e2	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 900  :          m_IdtGate[m_IntHandlers[i].number].offset_high   = (WORD)(m_IntHandlers[i].offset >> 16);

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	6b c0 07	 imul	 eax, 7
  000f0	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  000f6	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000f9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000fc	6b d2 07	 imul	 edx, 7
  000ff	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  00106	66 89 0c c5 06
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8+6], cx

; 901  :          m_IdtGate[m_IntHandlers[i].number].offset_low   = (WORD)(m_IntHandlers[i].offset & 0xffff);

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00111	6b c0 07	 imul	 eax, 7
  00114	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  0011a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00120	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00123	6b d2 07	 imul	 edx, 7
  00126	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  0012d	66 89 0c c5 00
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8], cx
$LN1@HalpStartI:

; 902  :       }
; 903  :       
; 904  :    }

  00135	e9 ec fe ff ff	 jmp	 $LN5@HalpStartI
$LN4@HalpStartI:

; 905  : 
; 906  :    //IDTR 설정
; 907  :    //IDT크기와 시작 Physical Address 설정 
; 908  :    m_IdtrDesc.address   = (int)&m_IdtGate;

  0013a	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_IdtrDesc+2, OFFSET _m_IdtGate

; 909  :    m_IdtrDesc.size      = (WORD)(MAX_IDT*sizeof(IDT_GATE));

  00144	66 c7 05 00 00
	00 00 00 02	 mov	 WORD PTR _m_IdtrDesc, 512 ; 00000200H

; 910  : 
; 911  :    //IDTR 포인터를 HalpEnableInterrupt로 전달 -> CPU가 IDT 테이블을 인식
; 912  :    HalpEnableInterrupt((PIDTR_DESC)&m_IdtrDesc);

  0014d	68 00 00 00 00	 push	 OFFSET _m_IdtrDesc
  00152	e8 00 00 00 00	 call	 _HalpEnableInterrupt
  00157	83 c4 04	 add	 esp, 4

; 913  : 
; 914  :    return TRUE;

  0015a	b8 01 00 00 00	 mov	 eax, 1

; 915  : }

  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
_HalpStartIntService ENDP
_TEXT	ENDS
END
