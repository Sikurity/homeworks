; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\Develop\HW\leeysos\kbddrv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_m_AsciiCode DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	08H
	DB	09H
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	00H
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03bH
	DB	027H
	DB	060H
	DB	00H
	DB	05cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	00H
	DB	02aH
	DB	00H
	DB	020H
	DB	00H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	08H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	05cH
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	08H
	DB	09H
	DB	051H
	DB	057H
	DB	045H
	DB	052H
	DB	054H
	DB	059H
	DB	055H
	DB	049H
	DB	04fH
	DB	050H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	00H
	DB	041H
	DB	053H
	DB	044H
	DB	046H
	DB	047H
	DB	048H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	03bH
	DB	027H
	DB	060H
	DB	00H
	DB	05cH
	DB	05aH
	DB	058H
	DB	043H
	DB	056H
	DB	042H
	DB	04eH
	DB	04dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	00H
	DB	02aH
	DB	00H
	DB	020H
	DB	00H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	08H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	05cH
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01bH
	DB	021H
	DB	040H
	DB	023H
	DB	024H
	DB	025H
	DB	05eH
	DB	026H
	DB	02aH
	DB	028H
	DB	029H
	DB	05fH
	DB	02bH
	DB	07eH
	DB	07eH
	DB	051H
	DB	057H
	DB	045H
	DB	052H
	DB	054H
	DB	059H
	DB	055H
	DB	049H
	DB	04fH
	DB	050H
	DB	07bH
	DB	07dH
	DB	07eH
	DB	00H
	DB	041H
	DB	053H
	DB	044H
	DB	046H
	DB	047H
	DB	048H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	03aH
	DB	027H
	DB	07eH
	DB	00H
	DB	07cH
	DB	05aH
	DB	058H
	DB	043H
	DB	056H
	DB	042H
	DB	04eH
	DB	04dH
	DB	03cH
	DB	03eH
	DB	03fH
	DB	00H
	DB	02aH
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01bH
	DB	021H
	DB	040H
	DB	023H
	DB	024H
	DB	025H
	DB	05eH
	DB	026H
	DB	02aH
	DB	028H
	DB	029H
	DB	05fH
	DB	02bH
	DB	07eH
	DB	07eH
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	07bH
	DB	07dH
	DB	07eH
	DB	00H
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03aH
	DB	027H
	DB	07eH
	DB	00H
	DB	07cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	03cH
	DB	03eH
	DB	03fH
	DB	00H
	DB	02aH
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	07fH
	DB	07fH
	DB	011H
	DB	017H
	DB	05H
	DB	012H
	DB	014H
	DB	019H
	DB	015H
	DB	09H
	DB	0fH
	DB	010H
	DB	02H
	DB	02H
	DB	0aH
	DB	00H
	DB	01H
	DB	013H
	DB	04H
	DB	06H
	DB	07H
	DB	08H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	018H
	DB	03H
	DB	016H
	DB	02H
	DB	0eH
	DB	0dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
PUBLIC	_KbdInitializeDriver
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_PsCreateThread:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_m_TranslatorThreadHandle DD 01H DUP (?)
_m_ProcessHandle DD 01H DUP (?)
_m_KbdData DB	0d3H DUP (?)
; Function compile flags: /Odtp /ZI
; File c:\develop\hw\leeysos\kbddrv.c
_BSS	ENDS
;	COMDAT _KbdInitializeDriver
_TEXT	SEGMENT
_KbdInitializeDriver PROC				; COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 115  : 	memset(&m_KbdData, 0, sizeof(m_KbdData));

  00009	68 d3 00 00 00	 push	 211			; 000000d3H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_KbdData
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 
; 117  : 	m_KbdData.indicator_status = KBD_LED_NUMLOCK;

  0001d	c6 05 00 00 00
	00 02		 mov	 BYTE PTR _m_KbdData, 2

; 118  : 
; 119  : 	// 현재 indicator_status 필드 설정된 값을 키보드 하드웨어에 전송하는 함수
; 120  : 	// <Num Lock>, <Cabs Lock>, <Scroll Lock> 중에서 <Num Lock>을 제외한 나머지 값은 모두 OFF 상태로 하고
; 121  : 	// 키보드에 이 값을 반영하기 위한 함수
; 122  : 
; 123  : 	KbdpResetIndicator();

  00024	e8 00 00 00 00	 call	 _KbdpResetIndicator

; 124  : 
; 125  : 	// 키보드 입력을 처리할 프로세스 생성
; 126  : 	if( !PsCreateProcess(&m_ProcessHandle) )

  00029	68 00 00 00 00	 push	 OFFSET _m_ProcessHandle
  0002e	e8 00 00 00 00	 call	 _PsCreateProcess
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	75 04		 jne	 SHORT $LN2@KbdInitial

; 127  : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 40		 jmp	 SHORT $LN3@KbdInitial
$LN2@KbdInitial:

; 128  : 
; 129  : 	// raw_key_data를 user_kay_data로 변형하는 기능을 하는 쓰레드 생성
; 130  : 	if( !PsCreateThread(&m_TranslatorThreadHandle, m_ProcessHandle, KbdpTranslatorThread, NULL, DEFAULT_STACK_SIZE, FALSE, HIGH) )

  0003e	6a 02		 push	 2
  00040	6a 00		 push	 0
  00042	68 00 00 01 00	 push	 65536			; 00010000H
  00047	6a 00		 push	 0
  00049	68 00 00 00 00	 push	 OFFSET _KbdpTranslatorThread
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ProcessHandle
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET _m_TranslatorThreadHandle
  00059	e8 00 00 00 00	 call	 _PsCreateThread
  0005e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00061	85 c0		 test	 eax, eax
  00063	75 04		 jne	 SHORT $LN1@KbdInitial

; 131  : 		return FALSE;

  00065	33 c0		 xor	 eax, eax
  00067	eb 15		 jmp	 SHORT $LN3@KbdInitial
$LN1@KbdInitial:

; 132  : 
; 133  : 	PsSetThreadStatus(m_TranslatorThreadHandle, THREAD_STATUS_READY);

  00069	6a 02		 push	 2
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_TranslatorThreadHandle
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _PsSetThreadStatus
  00076	83 c4 08	 add	 esp, 8

; 134  : 
; 135  : 	return TRUE;

  00079	b8 01 00 00 00	 mov	 eax, 1
$LN3@KbdInitial:

; 136  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_KbdInitializeDriver ENDP
_TEXT	ENDS
PUBLIC	_Kbd_IRQ_Handler
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Kbd_IRQ_Handler
_TEXT	SEGMENT
_keyCode$ = -1						; size = 1
_Kbd_IRQ_Handler PROC					; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 141  : 	UCHAR keyCode;
; 142  : 
; 143  : 	// User가 입력한 스캔 코드 값을 keycode 변수에 읽어옴
; 144  : 	keyCode = READ_PORT_UCHAR((PUCHAR)0x60);

  00009	6a 60		 push	 96			; 00000060H
  0000b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00010	83 c4 04	 add	 esp, 4
  00013	88 45 ff	 mov	 BYTE PTR _keyCode$[ebp], al

; 145  : 
; 146  : 	if( keyCode == 0xff || keyCode == 0x00 )	// Overrun

  00016	0f b6 45 ff	 movzx	 eax, BYTE PTR _keyCode$[ebp]
  0001a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0001f	74 08		 je	 SHORT $LN4@Kbd_IRQ_Ha
  00021	0f b6 45 ff	 movzx	 eax, BYTE PTR _keyCode$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	75 04		 jne	 SHORT $LN5@Kbd_IRQ_Ha
$LN4@Kbd_IRQ_Ha:

; 147  : 		return;

  00029	eb 20		 jmp	 SHORT $LN6@Kbd_IRQ_Ha
  0002b	eb 0d		 jmp	 SHORT $LN3@Kbd_IRQ_Ha
$LN5@Kbd_IRQ_Ha:

; 148  : 	else if( keyCode == 0xfa )					// Acknowledge

  0002d	0f b6 45 ff	 movzx	 eax, BYTE PTR _keyCode$[ebp]
  00031	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00036	75 02		 jne	 SHORT $LN3@Kbd_IRQ_Ha

; 149  : 		return;

  00038	eb 11		 jmp	 SHORT $LN6@Kbd_IRQ_Ha
$LN3@Kbd_IRQ_Ha:

; 150  : 
; 151  : 	// RAW Q에 Key Data를 넣고, IRQ 핸들러는 호출
; 152  : 	if( !KbdpPushRawKeyData(&(m_KbdData.raw_keydata_q), keyCode) )

  0003a	8a 45 ff	 mov	 al, BYTE PTR _keyCode$[ebp]
  0003d	50		 push	 eax
  0003e	68 0d 00 00 00	 push	 OFFSET _m_KbdData+13
  00043	e8 00 00 00 00	 call	 _KbdpPushRawKeyData
  00048	83 c4 08	 add	 esp, 8
$LN6@Kbd_IRQ_Ha:

; 153  : 		return;
; 154  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_Kbd_IRQ_Handler ENDP
_TEXT	ENDS
EXTRN	_HalTaskSwitch:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _KbdpTranslatorThread
_TEXT	SEGMENT
_key_family$ = -7					; size = 1
_indicator$ = -6					; size = 1
_raw_key$ = -5						; size = 1
_key_data$ = -4						; size = 2
_StartContext$ = 8					; size = 4
_KbdpTranslatorThread PROC				; COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN23@KbdpTransl:

; 237  : 	KBD_KEY_DATA key_data;
; 238  : 	BYTE raw_key, indicator, key_family;
; 239  : 
; 240  : 	// 반복문을 통해 하나씩 raw_keydata값을 user_keydata로 변경
; 241  : 
; 242  : 	while( 1 )

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	0f 84 a2 01 00
	00		 je	 $LN22@KbdpTransl

; 243  : 	{
; 244  : 		if( !KbdpPopRawKeyData(&(m_KbdData.raw_keydata_q), &raw_key) )

  00016	8d 45 fb	 lea	 eax, DWORD PTR _raw_key$[ebp]
  00019	50		 push	 eax
  0001a	68 0d 00 00 00	 push	 OFFSET _m_KbdData+13
  0001f	e8 00 00 00 00	 call	 _KbdpPopRawKeyData
  00024	83 c4 08	 add	 esp, 8
  00027	85 c0		 test	 eax, eax
  00029	75 07		 jne	 SHORT $LN21@KbdpTransl

; 245  : 		{
; 246  : 			HalTaskSwitch(); // RAW 큐에 더이상 값이 없을 때, 다른 Task로 Task Switching

  0002b	e8 00 00 00 00	 call	 _HalTaskSwitch

; 247  : 			continue;

  00030	eb d7		 jmp	 SHORT $LN23@KbdpTransl
$LN21@KbdpTransl:

; 248  : 		}
; 249  : 
; 250  : 		if( raw_key & 0x80 )

  00032	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00036	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0003b	74 53		 je	 SHORT $LN20@KbdpTransl

; 251  : 		{
; 252  : 			if( raw_key == 0xAA || raw_key == 0xB6 ) // Shift Key Breaked

  0003d	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00041	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  00046	74 0b		 je	 SHORT $LN18@KbdpTransl
  00048	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  0004c	3d b6 00 00 00	 cmp	 eax, 182		; 000000b6H
  00051	75 0c		 jne	 SHORT $LN19@KbdpTransl
$LN18@KbdpTransl:

; 253  : 				m_KbdData.shift_key_pressed = FALSE;

  00053	c7 05 01 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_KbdData+1, 0
  0005d	eb 2c		 jmp	 SHORT $LN17@KbdpTransl
$LN19@KbdpTransl:

; 254  : 			else if( raw_key == 0xB8 ) // Alt Key Breaked

  0005f	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00063	3d b8 00 00 00	 cmp	 eax, 184		; 000000b8H
  00068	75 0c		 jne	 SHORT $LN16@KbdpTransl

; 255  : 				m_KbdData.alt_key_pressed = FALSE;

  0006a	c7 05 09 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_KbdData+9, 0
  00074	eb 15		 jmp	 SHORT $LN17@KbdpTransl
$LN16@KbdpTransl:

; 256  : 			else if( raw_key == 0x9D ) // Ctrl Key Breaked

  00076	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  0007a	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  0007f	75 0a		 jne	 SHORT $LN17@KbdpTransl

; 257  : 				m_KbdData.ctrl_key_pressed = FALSE;

  00081	c7 05 05 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_KbdData+5, 0
$LN17@KbdpTransl:

; 258  : 			continue;

  0008b	e9 79 ff ff ff	 jmp	 $LN23@KbdpTransl
$LN20@KbdpTransl:

; 259  : 		}
; 260  : 
; 261  : 		// RESET INDICATORs
; 262  : 		if( raw_key == 0x45 ) // Num Lock

  00090	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00094	83 f8 45	 cmp	 eax, 69			; 00000045H
  00097	75 08		 jne	 SHORT $LN13@KbdpTransl

; 263  : 		{
; 264  : 			indicator = KBD_LED_NUMLOCK;

  00099	c6 45 fa 02	 mov	 BYTE PTR _indicator$[ebp], 2
  0009d	eb 20		 jmp	 SHORT $$reset_indicator$949

; 265  : 			goto $reset_indicator;

  0009f	eb 61		 jmp	 SHORT $LN12@KbdpTransl
$LN13@KbdpTransl:

; 266  : 		}
; 267  : 		else if( raw_key == 0x3A ) // Caps Lock

  000a1	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  000a5	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  000a8	75 08		 jne	 SHORT $LN11@KbdpTransl

; 268  : 		{
; 269  : 			indicator = KBD_LED_CAPSLOCK;

  000aa	c6 45 fa 04	 mov	 BYTE PTR _indicator$[ebp], 4
  000ae	eb 0f		 jmp	 SHORT $$reset_indicator$949

; 270  : 			goto $reset_indicator;

  000b0	eb 50		 jmp	 SHORT $LN12@KbdpTransl
$LN11@KbdpTransl:

; 271  : 		}
; 272  : 		else if( raw_key == 0x46 ) // Scroll Lock

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  000b6	83 f8 46	 cmp	 eax, 70			; 00000046H
  000b9	75 47		 jne	 SHORT $LN12@KbdpTransl

; 273  : 		{
; 274  : 			indicator = KBD_LED_SCROLLLOCK;

  000bb	c6 45 fa 01	 mov	 BYTE PTR _indicator$[ebp], 1
$$reset_indicator$949:

; 275  : $reset_indicator:
; 276  : 			if( m_KbdData.indicator_status & indicator )

  000bf	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_KbdData
  000c6	0f b6 4d fa	 movzx	 ecx, BYTE PTR _indicator$[ebp]
  000ca	23 c1		 and	 eax, ecx
  000cc	74 17		 je	 SHORT $LN8@KbdpTransl

; 277  : 				m_KbdData.indicator_status &= (~indicator);

  000ce	0f b6 45 fa	 movzx	 eax, BYTE PTR _indicator$[ebp]
  000d2	f7 d0		 not	 eax
  000d4	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_KbdData
  000db	23 c8		 and	 ecx, eax
  000dd	88 0d 00 00 00
	00		 mov	 BYTE PTR _m_KbdData, cl

; 278  : 			else

  000e3	eb 13		 jmp	 SHORT $LN7@KbdpTransl
$LN8@KbdpTransl:

; 279  : 				m_KbdData.indicator_status |= indicator;

  000e5	0f b6 45 fa	 movzx	 eax, BYTE PTR _indicator$[ebp]
  000e9	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_KbdData
  000f0	0b c8		 or	 ecx, eax
  000f2	88 0d 00 00 00
	00		 mov	 BYTE PTR _m_KbdData, cl
$LN7@KbdpTransl:

; 280  : 			KbdpResetIndicator();

  000f8	e8 00 00 00 00	 call	 _KbdpResetIndicator

; 281  : 			continue;

  000fd	e9 07 ff ff ff	 jmp	 $LN23@KbdpTransl
$LN12@KbdpTransl:

; 282  : 		}
; 283  : 
; 284  : 		// SHIFT, ALT, CTRL
; 285  : 		if( raw_key == 0x2A || raw_key == 0x36 )	// SHIFT

  00102	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00106	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00109	74 09		 je	 SHORT $LN5@KbdpTransl
  0010b	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  0010f	83 f8 36	 cmp	 eax, 54			; 00000036H
  00112	75 11		 jne	 SHORT $LN6@KbdpTransl
$LN5@KbdpTransl:

; 286  : 		{
; 287  : 			m_KbdData.shift_key_pressed = TRUE;

  00114	c7 05 01 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_KbdData+1, 1
  0011e	e9 e6 fe ff ff	 jmp	 $LN23@KbdpTransl

; 288  : 			continue;

  00123	eb 32		 jmp	 SHORT $LN4@KbdpTransl
$LN6@KbdpTransl:

; 289  : 		}
; 290  : 		else if( raw_key == 0x1D )	// CTRL

  00125	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00129	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  0012c	75 11		 jne	 SHORT $LN3@KbdpTransl

; 291  : 		{
; 292  : 			m_KbdData.ctrl_key_pressed = TRUE;

  0012e	c7 05 05 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_KbdData+5, 1
  00138	e9 cc fe ff ff	 jmp	 $LN23@KbdpTransl

; 293  : 			continue;

  0013d	eb 18		 jmp	 SHORT $LN4@KbdpTransl
$LN3@KbdpTransl:

; 294  : 		}
; 295  : 		else if( raw_key == 0x38 )	// ALT

  0013f	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00143	83 f8 38	 cmp	 eax, 56			; 00000038H
  00146	75 0f		 jne	 SHORT $LN4@KbdpTransl

; 296  : 		{
; 297  : 			m_KbdData.alt_key_pressed = TRUE;

  00148	c7 05 09 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_KbdData+9, 1

; 298  : 			continue;

  00152	e9 b2 fe ff ff	 jmp	 $LN23@KbdpTransl
$LN4@KbdpTransl:

; 299  : 		}
; 300  : 
; 301  : 		// GENERAL KEYs
; 302  : 		key_family = KBD_ASCII_ORG;

  00157	c6 45 f9 00	 mov	 BYTE PTR _key_family$[ebp], 0

; 303  : 		key_family |= (m_KbdData.shift_key_pressed ? KBD_ASCII_WITH_SHIFT : 0);

  0015b	a1 01 00 00 00	 mov	 eax, DWORD PTR _m_KbdData+1
  00160	f7 d8		 neg	 eax
  00162	1b c0		 sbb	 eax, eax
  00164	83 e0 02	 and	 eax, 2
  00167	0f b6 4d f9	 movzx	 ecx, BYTE PTR _key_family$[ebp]
  0016b	0b c8		 or	 ecx, eax
  0016d	88 4d f9	 mov	 BYTE PTR _key_family$[ebp], cl

; 304  : 		key_family |= (m_KbdData.indicator_status & KBD_LED_CAPSLOCK ? KBD_ASCII_WITH_CAPSLOCK : 0);

  00170	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_KbdData
  00177	83 e0 04	 and	 eax, 4
  0017a	f7 d8		 neg	 eax
  0017c	1b c0		 sbb	 eax, eax
  0017e	f7 d8		 neg	 eax
  00180	0f b6 4d f9	 movzx	 ecx, BYTE PTR _key_family$[ebp]
  00184	0b c8		 or	 ecx, eax
  00186	88 4d f9	 mov	 BYTE PTR _key_family$[ebp], cl

; 305  : 
; 306  : 		key_data.type = KBD_KTYPE_GENERAL;

  00189	c6 45 fc 00	 mov	 BYTE PTR _key_data$[ebp], 0

; 307  : 		key_data.key = m_AsciiCode[key_family][raw_key];

  0018d	0f b6 45 f9	 movzx	 eax, BYTE PTR _key_family$[ebp]
  00191	c1 e0 07	 shl	 eax, 7
  00194	0f b6 4d fb	 movzx	 ecx, BYTE PTR _raw_key$[ebp]
  00198	8a 94 08 00 00
	00 00		 mov	 dl, BYTE PTR _m_AsciiCode[eax+ecx]
  0019f	88 55 fd	 mov	 BYTE PTR _key_data$[ebp+1], dl

; 308  : 
; 309  : 		KbdpPushUserKeyData(&(m_KbdData.user_keydata_q), &key_data);

  001a2	8d 45 fc	 lea	 eax, DWORD PTR _key_data$[ebp]
  001a5	50		 push	 eax
  001a6	68 50 00 00 00	 push	 OFFSET _m_KbdData+80
  001ab	e8 00 00 00 00	 call	 _KbdpPushUserKeyData
  001b0	83 c4 08	 add	 esp, 8

; 310  : 	}

  001b3	e9 51 fe ff ff	 jmp	 $LN23@KbdpTransl
$LN22@KbdpTransl:

; 311  : 	
; 312  : 	return 0;

  001b8	33 c0		 xor	 eax, eax

; 313  : }

  001ba	5f		 pop	 edi
  001bb	5e		 pop	 esi
  001bc	5b		 pop	 ebx
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
_KbdpTranslatorThread ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _KbdpResetIndicator
_TEXT	SEGMENT
_status$ = -1						; size = 1
_KbdpResetIndicator PROC				; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN6@KbdpResetI:

; 318  : 	UCHAR status;
; 319  : 
; 320  : 	// 0x64번 포트에서 키보드의 상태를 확인
; 321  : 	// input buffer가 비어있으면 0xED 명령으로 입출력 포트인 0x60 포트에 넣어준다
; 322  : 	// 0xED : 현재 키보드의 Indicator LED 값을 설정하는 명령어
; 323  : 
; 324  : 	do
; 325  : 	{
; 326  : 		status = READ_PORT_UCHAR((PUCHAR)0x64);

  00009	6a 64		 push	 100			; 00000064H
  0000b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00010	83 c4 04	 add	 esp, 4
  00013	88 45 ff	 mov	 BYTE PTR _status$[ebp], al

; 327  : 	}
; 328  : 	while( status & 0x02 );

  00016	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	75 ea		 jne	 SHORT $LN6@KbdpResetI

; 329  : 
; 330  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, 0xED);

  0001f	68 ed 00 00 00	 push	 237			; 000000edH
  00024	6a 60		 push	 96			; 00000060H
  00026	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002b	83 c4 08	 add	 esp, 8
$LN3@KbdpResetI:

; 331  : 
; 332  : 	// 이전에 우리가 설정했던 indicator의 값을 키보드로 보내준다.
; 333  : 	// 키보드가 LED를 모두 불빛이 사라지게 한다.
; 334  : 	do
; 335  : 	{
; 336  : 		status = READ_PORT_UCHAR((PUCHAR)0x64);

  0002e	6a 64		 push	 100			; 00000064H
  00030	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00035	83 c4 04	 add	 esp, 4
  00038	88 45 ff	 mov	 BYTE PTR _status$[ebp], al

; 337  : 	}
; 338  : 	while( status & 0x02 );

  0003b	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0003f	83 e0 02	 and	 eax, 2
  00042	75 ea		 jne	 SHORT $LN3@KbdpResetI

; 339  : 
; 340  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, m_KbdData.indicator_status);

  00044	a0 00 00 00 00	 mov	 al, BYTE PTR _m_KbdData
  00049	50		 push	 eax
  0004a	6a 60		 push	 96			; 00000060H
  0004c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00051	83 c4 08	 add	 esp, 8

; 341  : 
; 342  : 	return 0;

  00054	33 c0		 xor	 eax, eax

; 343  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_KbdpResetIndicator ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPopRawKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_pKey$ = 12						; size = 4
_KbdpPopRawKeyData PROC					; COMDAT

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 348  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 349  : 
; 350  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 351  : 	{
; 352  : 		// count 체크
; 353  : 		if( pKeyQ->cnt == 0 )

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN2@KbdpPopRaw

; 354  : 		{
; 355  : 			bResult = FALSE;

  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 356  : 			goto $exit;

  00023	eb 41		 jmp	 SHORT $$exit$982
$LN2@KbdpPopRaw:

; 357  : 		}
; 358  : 
; 359  : 		pKeyQ->cnt--;

  00025	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00028	8a 08		 mov	 cl, BYTE PTR [eax]
  0002a	80 e9 01	 sub	 cl, 1
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00030	88 0a		 mov	 BYTE PTR [edx], cl

; 360  : 		*pKey = pKeyQ->queue[pKeyQ->head++];

  00032	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _pKey$[ebp]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0003f	8a 4c 08 03	 mov	 cl, BYTE PTR [eax+ecx+3]
  00043	88 0a		 mov	 BYTE PTR [edx], cl
  00045	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00048	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  0004b	04 01		 add	 al, 1
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _pKeyQ$[ebp]
  00050	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 361  : 		if( pKeyQ->head >= RAW_KEY_DATA_Q_SIZE )

  00053	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00056	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0005a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0005d	7c 07		 jl	 SHORT $$exit$982

; 362  : 			pKeyQ->head = 0;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00062	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$$exit$982:

; 363  : 	}
; 364  : $exit :
; 365  : EXIT_CRITICAL_SECTION();

  00066	9d		 popfd

; 366  : 	return bResult;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 367  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_KbdpPopRawKeyData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPushRawKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_key$ = 12						; size = 1
_KbdpPushRawKeyData PROC				; COMDAT

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 372  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 373  : 
; 374  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 375  : 	{
; 376  : 		// 큐에 남은 공간 체크
; 377  : 		if( pKeyQ->cnt >= RAW_KEY_DATA_Q_SIZE )

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0001b	7c 09		 jl	 SHORT $LN2@KbdpPushRa

; 378  : 		{
; 379  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 380  : 			goto $exit;

  00024	eb 40		 jmp	 SHORT $$exit$991
$LN2@KbdpPushRa:

; 381  : 		}
; 382  : 
; 383  : 		pKeyQ->cnt++;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00029	8a 08		 mov	 cl, BYTE PTR [eax]
  0002b	80 c1 01	 add	 cl, 1
  0002e	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00031	88 0a		 mov	 BYTE PTR [edx], cl

; 384  : 		pKeyQ->queue[pKeyQ->tail++] = key;

  00033	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00036	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  0003d	8a 45 0c	 mov	 al, BYTE PTR _key$[ebp]
  00040	88 44 0a 03	 mov	 BYTE PTR [edx+ecx+3], al
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pKeyQ$[ebp]
  00047	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0004a	80 c2 01	 add	 dl, 1
  0004d	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00050	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 385  : 		if( pKeyQ->tail >= RAW_KEY_DATA_Q_SIZE )

  00053	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00056	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0005a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0005d	7c 07		 jl	 SHORT $$exit$991

; 386  : 			pKeyQ->tail = 0;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00062	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$$exit$991:

; 387  : 	}
; 388  : $exit :
; 389  : EXIT_CRITICAL_SECTION();

  00066	9d		 popfd

; 390  : 	return bResult;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 391  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_KbdpPushRawKeyData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPushUserKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_pKeyData$ = 12						; size = 4
_KbdpPushUserKeyData PROC				; COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 422  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 423  : 
; 424  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 425  : 	{
; 426  : 		// 큐에 남은 공간 체크
; 427  : 		if( pKeyQ->cnt >= USER_KEY_DATA_Q_SIZE )

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0001b	7c 09		 jl	 SHORT $LN2@KbdpPushUs

; 428  : 		{
; 429  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 430  : 			goto $exit;

  00024	eb 56		 jmp	 SHORT $$exit$1009
$LN2@KbdpPushUs:

; 431  : 		}
; 432  : 
; 433  : 		pKeyQ->cnt++;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00029	8a 08		 mov	 cl, BYTE PTR [eax]
  0002b	80 c1 01	 add	 cl, 1
  0002e	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00031	88 0a		 mov	 BYTE PTR [edx], cl

; 434  : 		pKeyData->type = pKeyQ->queue[pKeyQ->tail].type;

  00033	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00036	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0003a	8b 55 0c	 mov	 edx, DWORD PTR _pKeyData$[ebp]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00040	8a 4c 48 03	 mov	 cl, BYTE PTR [eax+ecx*2+3]
  00044	88 0a		 mov	 BYTE PTR [edx], cl

; 435  : 		pKeyData->key = pKeyQ->queue[pKeyQ->tail].key;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00049	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0004d	8b 55 0c	 mov	 edx, DWORD PTR _pKeyData$[ebp]
  00050	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00053	8a 4c 48 04	 mov	 cl, BYTE PTR [eax+ecx*2+4]
  00057	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 436  : 		pKeyQ->tail++;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0005d	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00060	80 c1 01	 add	 cl, 1
  00063	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00066	88 4a 02	 mov	 BYTE PTR [edx+2], cl

; 437  : 		if( pKeyQ->tail >= USER_KEY_DATA_Q_SIZE )

  00069	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0006c	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00070	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00073	7c 07		 jl	 SHORT $$exit$1009

; 438  : 			pKeyQ->tail = 0;

  00075	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00078	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$$exit$1009:

; 439  : 	}
; 440  : $exit :
; 441  : EXIT_CRITICAL_SECTION();

  0007c	9d		 popfd

; 442  : 	return bResult;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 443  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_KbdpPushUserKeyData ENDP
_TEXT	ENDS
END
