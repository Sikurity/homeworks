; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\Develop\HW\leeysos\mmanager.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@ ; `string'
PUBLIC	??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@ ; `string'
PUBLIC	_MmkInitializeMemoryManager
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@
; File c:\develop\hw\leeysos\mmanager.c
CONST	SEGMENT
??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@ DB 'Memo'
	DB	'ry Manager is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@ DB 'MmpCreat'
	DB	'eMemPoolBlk() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@
CONST	SEGMENT
??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@ DB 'MmpCheck'
	DB	'MemorySize() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _MmkInitializeMemoryManager
_TEXT	SEGMENT
_MmkInitializeMemoryManager PROC			; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 40   : 	if( !MmpCheckMemorySize() )

  00009	e8 00 00 00 00	 call	 _MmpCheckMemorySize
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN2@MmkInitial

; 41   : 	{
; 42   : 		DbgPrint("MmpCheckMemorySize() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 43   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 2c		 jmp	 SHORT $LN3@MmkInitial
$LN2@MmkInitial:

; 44   : 	}
; 45   : 
; 46   : 	// 메모리 초기화 모듈
; 47   : 	if( !MmpCreateMemPoolBlk() )

  00023	e8 00 00 00 00	 call	 _MmpCreateMemPoolBlk
  00028	85 c0		 test	 eax, eax
  0002a	75 11		 jne	 SHORT $LN1@MmkInitial

; 48   : 	{
; 49   : 		DbgPrint("MmpCreateMemPoolBlk() returned an error.\r\n");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@
  00031	e8 00 00 00 00	 call	 _CrtPrintf
  00036	83 c4 04	 add	 esp, 4

; 50   : 		return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 12		 jmp	 SHORT $LN3@MmkInitial
$LN1@MmkInitial:

; 51   : 	}
; 52   : 	DbgPrint("Memory Manager is initialized!!\r\n");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@
  00042	e8 00 00 00 00	 call	 _CrtPrintf
  00047	83 c4 04	 add	 esp, 4

; 53   : 
; 54   : 	return TRUE;

  0004a	b8 01 00 00 00	 mov	 eax, 1
$LN3@MmkInitial:

; 55   : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_MmkInitializeMemoryManager ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_MemSize DD	01H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _MmpCheckMemorySize
_TEXT	SEGMENT
_tmp$ = -12						; size = 4
_pAddr$ = -8						; size = 4
_bResult$ = -4						; size = 4
_MmpCheckMemorySize PROC				; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 59   : 	BOOL bResult;
; 60   : 	DWORD *pAddr = (DWORD *)0x00000000, tmp;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pAddr$[ebp], 0
$LN3@MmpCheckMe:

; 61   : 
; 62   : 	// 메모리 최대값 확인
; 63   : 
; 64   : 	while( 1 )

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 33		 je	 SHORT $LN2@MmpCheckMe

; 65   : 	{
; 66   : 		//4MB 단위로 메모리 위치 변경
; 67   : 		pAddr += (4 * 1024 * 1024);

  00019	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  0001c	05 00 00 00 01	 add	 eax, 16777216		; 01000000H
  00021	89 45 f8	 mov	 DWORD PTR _pAddr$[ebp], eax

; 68   : 
; 69   : 		//tmp에 이전 메모리 위치에 있던 값 저장
; 70   : 
; 71   : 		tmp = *pAddr;

  00024	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f4	 mov	 DWORD PTR _tmp$[ebp], ecx

; 72   : 		*pAddr = 0x11223344;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  0002f	c7 00 44 33 22
	11		 mov	 DWORD PTR [eax], 287454020 ; 11223344H

; 73   : 
; 74   : 		if( *pAddr != 0x11223344 )

  00035	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00038	81 38 44 33 22
	11		 cmp	 DWORD PTR [eax], 287454020 ; 11223344H
  0003e	74 02		 je	 SHORT $LN1@MmpCheckMe

; 75   : 			break;

  00040	eb 0a		 jmp	 SHORT $LN2@MmpCheckMe
$LN1@MmpCheckMe:

; 76   : 
; 77   : 		*pAddr = tmp;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00048	89 08		 mov	 DWORD PTR [eax], ecx

; 78   : 	}

  0004a	eb c4		 jmp	 SHORT $LN3@MmpCheckMe
$LN2@MmpCheckMe:

; 79   : 
; 80   : ENTER_CRITICAL_SECTION();

  0004c	9c		 pushfd
  0004d	fa		 cli

; 81   : 
; 82   : 	m_MemSize = (DWORD)pAddr;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00051	a3 00 00 00 00	 mov	 DWORD PTR _m_MemSize, eax

; 83   : 	bResult = (m_MemSize < MEMORY_POOL_START_ADDRESS + (1 * 1024 * 1024) ? FALSE : TRUE);

  00056	81 3d 00 00 00
	00 00 00 30 00	 cmp	 DWORD PTR _m_MemSize, 3145728 ; 00300000H
  00060	1b c0		 sbb	 eax, eax
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 fc	 mov	 DWORD PTR _bResult$[ebp], eax

; 84   : 
; 85   : EXIT_CRITICAL_SECTION();

  00068	9d		 popfd

; 86   : 
; 87   : 	return bResult;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 88   : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_MmpCheckMemorySize ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_MemBlkManager DB 014H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _MmpCreateMemPoolBlk
_TEXT	SEGMENT
_pCur$ = -32						; size = 4
_pPrev$ = -28						; size = 4
_pPoolEntry$ = -24					; size = 4
_i$ = -20						; size = 4
_dwBlksOfDescs$ = -16					; size = 4
_dwBlksOfAllocatableMem$ = -12				; size = 4
_dwBlksOfUsableMem$ = -8				; size = 4
_dwUsableMemSize$ = -4					; size = 4
_MmpCreateMemPoolBlk PROC				; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 92   : 	DWORD dwUsableMemSize;
; 93   : 	DWORD dwBlksOfUsableMem;
; 94   : 	DWORD dwBlksOfAllocatableMem;
; 95   : 	DWORD dwBlksOfDescs;
; 96   : 	DWORD i;
; 97   : 
; 98   : 	int *pPoolEntry;
; 99   : 	MEM_BLK_DESC *pPrev, *pCur;
; 100  : 
; 101  : 	// 각 변수들 초기화
; 102  : 	// 사용 가능한 Memory의 Byte 단위 크기
; 103  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 104  : 	dwUsableMemSize = m_MemSize - MEMORY_POOL_START_ADDRESS;

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_MemSize
  00010	2d 00 00 20 00	 sub	 eax, 2097152		; 00200000H
  00015	89 45 fc	 mov	 DWORD PTR _dwUsableMemSize$[ebp], eax

; 105  : EXIT_CRITICAL_SECTION();

  00018	9d		 popfd

; 106  : 
; 107  : 	// 사용 가능한 Memory block수를 계산
; 108  : 	dwBlksOfUsableMem	= MmpGetRequiredBlocksFromBytes(dwUsableMemSize);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _dwUsableMemSize$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 f8	 mov	 DWORD PTR _dwBlksOfUsableMem$[ebp], eax

; 109  : 
; 110  : 	// 사용 가능한 Memory block을 관리하는데 필요한 Memory Descriptor의 수
; 111  : 	dwBlksOfDescs		= MmpGetRequiredBlocksFromBytes(dwBlksOfUsableMem * sizeof(MEM_BLK_DESC));

  00028	8b 45 f8	 mov	 eax, DWORD PTR _dwBlksOfUsableMem$[ebp]
  0002b	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 f0	 mov	 DWORD PTR _dwBlksOfDescs$[ebp], eax

; 112  : 	
; 113  : 	// 할당 가능한 Memory block수를 계산
; 114  : 	dwBlksOfAllocatableMem = dwBlksOfUsableMem - dwBlksOfDescs;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dwBlksOfUsableMem$[ebp]
  0003d	2b 45 f0	 sub	 eax, DWORD PTR _dwBlksOfDescs$[ebp]
  00040	89 45 f4	 mov	 DWORD PTR _dwBlksOfAllocatableMem$[ebp], eax

; 115  : 
; 116  : 	// 할당 가능한 Memory block을 관리하는데 필요한 Memory Descriptor의 수
; 117  : 	dwBlksOfDescs = MmpGetRequiredBlocksFromBytes(dwBlksOfAllocatableMem * sizeof(MEM_BLK_DESC));

  00043	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  00046	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 f0	 mov	 DWORD PTR _dwBlksOfDescs$[ebp], eax

; 118  : 	// Memory block의 시작위치를 지정
; 119  : 
; 120  : 	pPoolEntry = (int *)(MEMORY_POOL_START_ADDRESS + dwBlksOfDescs * MEM_BLK_SIZE);

  00055	8b 45 f0	 mov	 eax, DWORD PTR _dwBlksOfDescs$[ebp]
  00058	c1 e0 09	 shl	 eax, 9
  0005b	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  00060	89 45 e8	 mov	 DWORD PTR _pPoolEntry$[ebp], eax

; 121  : 
; 122  : ENTER_CRITICAL_SECTION();

  00063	9c		 pushfd
  00064	fa		 cli

; 123  : 
; 124  : 	m_MemBlkManager.nBlocks		= dwBlksOfAllocatableMem;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR _m_MemBlkManager, eax

; 125  : 	m_MemBlkManager.nUsedBlocks	= 0;

  0006d	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, 0

; 126  : 	m_MemBlkManager.nFreeBlocks	= dwBlksOfAllocatableMem;

  00077	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  0007a	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 127  : 	m_MemBlkManager.pDescEntry	= (MEM_BLK_DESC *)MEMORY_POOL_START_ADDRESS;

  0007f	c7 05 0c 00 00
	00 00 00 20 00	 mov	 DWORD PTR _m_MemBlkManager+12, 2097152 ; 00200000H

; 128  : 	m_MemBlkManager.pPoolEntry	= pPoolEntry;

  00089	8b 45 e8	 mov	 eax, DWORD PTR _pPoolEntry$[ebp]
  0008c	a3 10 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+16, eax

; 129  : 
; 130  : 	pPrev = m_MemBlkManager.pDescEntry;

  00091	a1 0c 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+12
  00096	89 45 e4	 mov	 DWORD PTR _pPrev$[ebp], eax

; 131  : 	pPrev->status = MEM_BLK_FREE;

  00099	8b 45 e4	 mov	 eax, DWORD PTR _pPrev$[ebp]
  0009c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 132  : 
; 133  : 	// Memory Block을 전부 초기화
; 134  : 	for( i = 1 ; i < dwBlksOfAllocatableMem ; i++ )

  000a2	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000a9	eb 09		 jmp	 SHORT $LN3@MmpCreateM
$LN2@MmpCreateM:
  000ab	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmpCreateM:
  000b4	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000b7	3b 45 f4	 cmp	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  000ba	73 32		 jae	 SHORT $LN1@MmpCreateM

; 135  : 	{
; 136  : 		pCur = (MEM_BLK_DESC *)(MEMORY_POOL_START_ADDRESS + sizeof(MEM_BLK_DESC) * i);

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	6b c0 0c	 imul	 eax, 12			; 0000000cH
  000c2	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  000c7	89 45 e0	 mov	 DWORD PTR _pCur$[ebp], eax

; 137  : 		pCur->status = MEM_BLK_FREE;

  000ca	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 138  : 		pCur->block_size = 0;

  000d3	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000d6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 139  : 		pPrev->pNext = pCur;

  000dd	8b 45 e4	 mov	 eax, DWORD PTR _pPrev$[ebp]
  000e0	8b 4d e0	 mov	 ecx, DWORD PTR _pCur$[ebp]
  000e3	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 140  : 		pPrev = pCur;

  000e6	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000e9	89 45 e4	 mov	 DWORD PTR _pPrev$[ebp], eax

; 141  : 	}

  000ec	eb bd		 jmp	 SHORT $LN2@MmpCreateM
$LN1@MmpCreateM:

; 142  : 
; 143  : 	pCur->pNext = NULL;

  000ee	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000f1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 144  : EXIT_CRITICAL_SECTION();

  000f8	9d		 popfd

; 145  : 
; 146  : 	return TRUE;

  000f9	b8 01 00 00 00	 mov	 eax, 1

; 147  : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_MmpCreateMemPoolBlk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetRequiredBlocksFromBytes
_TEXT	SEGMENT
_dwBlocks$ = -4						; size = 4
_bytes$ = 8						; size = 4
_MmpGetRequiredBlocksFromBytes PROC			; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 151  : 	DWORD dwBlocks = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwBlocks$[ebp], 0

; 152  : 
; 153  : 	dwBlocks = bytes / MEM_BLK_SIZE;

  00010	8b 45 08	 mov	 eax, DWORD PTR _bytes$[ebp]
  00013	c1 e8 09	 shr	 eax, 9
  00016	89 45 fc	 mov	 DWORD PTR _dwBlocks$[ebp], eax

; 154  : 
; 155  : 	if( bytes % MEM_BLK_SIZE )

  00019	8b 45 08	 mov	 eax, DWORD PTR _bytes$[ebp]
  0001c	33 d2		 xor	 edx, edx
  0001e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00023	f7 f1		 div	 ecx
  00025	85 d2		 test	 edx, edx
  00027	74 09		 je	 SHORT $LN1@MmpGetRequ

; 156  : 		dwBlocks++;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _dwBlocks$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR _dwBlocks$[ebp], eax
$LN1@MmpGetRequ:

; 157  : 
; 158  : 	return dwBlocks;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _dwBlocks$[ebp]

; 159  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_MmpGetRequiredBlocksFromBytes ENDP
_TEXT	ENDS
PUBLIC	_MmAllocateNonCachedMemory
; Function compile flags: /Odtp /ZI
;	COMDAT _MmAllocateNonCachedMemory
_TEXT	SEGMENT
_pCur$ = -20						; size = 4
_pAllocStart$ = -16					; size = 4
_i$ = -12						; size = 4
_dwCurBlocks$ = -8					; size = 4
_dwRequiredBlocks$ = -4					; size = 4
_NumberOfBytes$ = 8					; size = 4
_MmAllocateNonCachedMemory PROC				; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 166  : 	DWORD dwRequiredBlocks, dwCurBlocks, i;
; 167  : 	MEM_BLK_DESC *pAllocStart, *pCur;
; 168  : 
; 169  : 	// 요청된 바이트가 0일 경우 NULL을 리턴
; 170  : 	if( NumberOfBytes == 0 )

  00009	83 7d 08 00	 cmp	 DWORD PTR _NumberOfBytes$[ebp], 0
  0000d	75 07		 jne	 SHORT $LN9@MmAllocate

; 171  : 		return (VOID *)NULL;

  0000f	33 c0		 xor	 eax, eax
  00011	e9 f5 00 00 00	 jmp	 $LN10@MmAllocate
$LN9@MmAllocate:

; 172  : 
; 173  : 	// 요청된 바이트를 블록 단위로 변경해서 시스템에 남아있는 블록의 수와 비교
; 174  : 	// 이 후, 할당 가능한 블록이 부족할 경우 NULL을 리턴
; 175  : 	dwRequiredBlocks = MmpGetRequiredBlocksFromBytes(NumberOfBytes);

  00016	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR _dwRequiredBlocks$[ebp], eax

; 176  : 
; 177  : ENTER_CRITICAL_SECTION();

  00025	9c		 pushfd
  00026	fa		 cli

; 178  : 
; 179  : 	if( m_MemBlkManager.nFreeBlocks < dwRequiredBlocks )

  00027	a1 08 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+8
  0002c	3b 45 fc	 cmp	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  0002f	73 08		 jae	 SHORT $LN8@MmAllocate

; 180  : 	{
; 181  : 
; 182  : EXIT_CRITICAL_SECTION();

  00031	9d		 popfd

; 183  : 	
; 184  : 		return (VOID *)NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 d2 00 00 00	 jmp	 $LN10@MmAllocate
$LN8@MmAllocate:

; 185  : 	}
; 186  : 
; 187  : 	// 메모리 디스크립터 리스트를 검색하여 할당 가능한 공간을 찾는다
; 188  : 	pAllocStart = pCur = m_MemBlkManager.pDescEntry;

  00039	a1 0c 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+12
  0003e	89 45 ec	 mov	 DWORD PTR _pCur$[ebp], eax
  00041	8b 4d ec	 mov	 ecx, DWORD PTR _pCur$[ebp]
  00044	89 4d f0	 mov	 DWORD PTR _pAllocStart$[ebp], ecx

; 189  : 	dwCurBlocks = 0;

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwCurBlocks$[ebp], 0
$LN7@MmAllocate:

; 190  : 	while( dwCurBlocks < dwRequiredBlocks )

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _dwCurBlocks$[ebp]
  00051	3b 45 fc	 cmp	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  00054	73 4b		 jae	 SHORT $LN6@MmAllocate

; 191  : 	{
; 192  : 		if( pCur->pNext == NULL )

  00056	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  00059	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0005d	75 08		 jne	 SHORT $LN5@MmAllocate

; 193  : 		{
; 194  : 			
; 195  : EXIT_CRITICAL_SECTION();

  0005f	9d		 popfd

; 196  : 	
; 197  : 			return (VOID *)NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 a4 00 00 00	 jmp	 $LN10@MmAllocate
$LN5@MmAllocate:

; 198  : 		}
; 199  : 
; 200  : 		if( pCur->status == MEM_BLK_USED )

  00067	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  0006a	83 38 01	 cmp	 DWORD PTR [eax], 1
  0006d	75 1e		 jne	 SHORT $LN4@MmAllocate

; 201  : 		{
; 202  : 			dwCurBlocks = 0;

  0006f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwCurBlocks$[ebp], 0

; 203  : 			pAllocStart = pCur = pCur + pCur->block_size;

  00076	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  00079	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007c	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0007f	03 4d ec	 add	 ecx, DWORD PTR _pCur$[ebp]
  00082	89 4d ec	 mov	 DWORD PTR _pCur$[ebp], ecx
  00085	8b 55 ec	 mov	 edx, DWORD PTR _pCur$[ebp]
  00088	89 55 f0	 mov	 DWORD PTR _pAllocStart$[ebp], edx

; 204  : 			continue;

  0008b	eb c1		 jmp	 SHORT $LN7@MmAllocate
$LN4@MmAllocate:

; 205  : 		}
; 206  : 
; 207  : 		dwCurBlocks++;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _dwCurBlocks$[ebp]
  00090	83 c0 01	 add	 eax, 1
  00093	89 45 f8	 mov	 DWORD PTR _dwCurBlocks$[ebp], eax

; 208  : 		pCur = pCur->pNext;

  00096	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  00099	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009c	89 4d ec	 mov	 DWORD PTR _pCur$[ebp], ecx

; 209  : 	}

  0009f	eb ad		 jmp	 SHORT $LN7@MmAllocate
$LN6@MmAllocate:

; 210  : 
; 211  : 	// 할당 가능한 공간을 찾은 후, 해당 메모리 블록의 상태를 USED로 변경
; 212  : 	pCur = pAllocStart;

  000a1	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
  000a4	89 45 ec	 mov	 DWORD PTR _pCur$[ebp], eax

; 213  : 
; 214  : 	for( i = 0 ; i < dwRequiredBlocks ; i++ )

  000a7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ae	eb 09		 jmp	 SHORT $LN3@MmAllocate
$LN2@MmAllocate:
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmAllocate:
  000b9	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	3b 45 fc	 cmp	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  000bf	73 14		 jae	 SHORT $LN1@MmAllocate

; 215  : 	{
; 216  : 		pCur->status = MEM_BLK_USED;

  000c1	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  000c4	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 217  : 		pCur = pCur->pNext;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  000cd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d0	89 4d ec	 mov	 DWORD PTR _pCur$[ebp], ecx

; 218  : 	}

  000d3	eb db		 jmp	 SHORT $LN2@MmAllocate
$LN1@MmAllocate:

; 219  : 
; 220  : 	pAllocStart->block_size = dwRequiredBlocks;

  000d5	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _dwRequiredBlocks$[ebp]
  000db	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 221  : 
; 222  : 	m_MemBlkManager.nFreeBlocks -= dwRequiredBlocks;

  000de	a1 08 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+8
  000e3	2b 45 fc	 sub	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  000e6	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 223  : 	m_MemBlkManager.nUsedBlocks += dwRequiredBlocks;

  000eb	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+4
  000f0	03 45 fc	 add	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  000f3	a3 04 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, eax

; 224  : 
; 225  : 	// 할당된 메모리 블록의 실제 주소를 받아온다
; 226  : 	pAllocStart = (MEM_BLK_DESC *)MmpGetPoolAddrFromDescAddr(pAllocStart);

  000f8	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _MmpGetPoolAddrFromDescAddr
  00101	83 c4 04	 add	 esp, 4
  00104	89 45 f0	 mov	 DWORD PTR _pAllocStart$[ebp], eax

; 227  : 
; 228  : EXIT_CRITICAL_SECTION();

  00107	9d		 popfd

; 229  : 
; 230  : 	return (VOID *)pAllocStart;

  00108	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
$LN10@MmAllocate:

; 231  : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
_MmAllocateNonCachedMemory ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetPoolAddrFromDescAddr
_TEXT	SEGMENT
_ResultAddr$ = -4					; size = 4
_pDescAddr$ = 8						; size = 4
_MmpGetPoolAddrFromDescAddr PROC			; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	int ResultAddr;
; 237  : 
; 238  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 239  : 
; 240  : 	// 메모리 풀에서 메모리 블록의 시작 주소 가지고온다.
; 241  : 	ResultAddr = (int)(m_MemBlkManager.pPoolEntry);

  0000b	a1 10 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+16
  00010	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 242  : 	// 할당된 메모리 블록의 실제주소를 구한다.
; 243  : 	ResultAddr += (int)((pDescAddr - m_MemBlkManager.pDescEntry) * MEM_BLK_SIZE);

  00013	8b 45 08	 mov	 eax, DWORD PTR _pDescAddr$[ebp]
  00016	2b 05 0c 00 00
	00		 sub	 eax, DWORD PTR _m_MemBlkManager+12
  0001c	99		 cdq
  0001d	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00022	f7 f9		 idiv	 ecx
  00024	c1 e0 09	 shl	 eax, 9
  00027	03 45 fc	 add	 eax, DWORD PTR _ResultAddr$[ebp]
  0002a	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 244  : 
; 245  : EXIT_CRITICAL_SECTION();

  0002d	9d		 popfd

; 246  : 
; 247  : 	return (VOID *)ResultAddr;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]

; 248  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_MmpGetPoolAddrFromDescAddr ENDP
_TEXT	ENDS
PUBLIC	_MmFreeNonCachedMemory
; Function compile flags: /Odtp /ZI
;	COMDAT _MmFreeNonCachedMemory
_TEXT	SEGMENT
_dwBlockSize$ = -12					; size = 4
_i$ = -8						; size = 4
_pCur$ = -4						; size = 4
_BaseAddress$ = 8					; size = 4
_MmFreeNonCachedMemory PROC				; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 252  : 	MEM_BLK_DESC *pCur;
; 253  : 	DWORD i, dwBlockSize;
; 254  : 
; 255  : 	if( BaseAddress == NULL )

  00009	83 7d 08 00	 cmp	 DWORD PTR _BaseAddress$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN5@MmFreeNonC

; 256  : 		return;

  0000f	eb 78		 jmp	 SHORT $LN6@MmFreeNonC
$LN5@MmFreeNonC:

; 257  : 
; 258  : 	// 해제하고자 하는 메모리 블록의 디스크립터 리스트를 검색
; 259  : 	pCur = (MEM_BLK_DESC *)MmpGetDescAddrFromPoolAddr(BaseAddress);

  00011	8b 45 08	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _MmpGetDescAddrFromPoolAddr
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 fc	 mov	 DWORD PTR _pCur$[ebp], eax

; 260  : 
; 261  : ENTER_CRITICAL_SECTION();

  00020	9c		 pushfd
  00021	fa		 cli

; 262  : 
; 263  : 	if( pCur->status != MEM_BLK_USED )

  00022	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00025	83 38 01	 cmp	 DWORD PTR [eax], 1
  00028	74 03		 je	 SHORT $LN4@MmFreeNonC

; 264  : 	{
; 265  : 
; 266  : EXIT_CRITICAL_SECTION();

  0002a	9d		 popfd

; 267  : 
; 268  : 		return;

  0002b	eb 5c		 jmp	 SHORT $LN6@MmFreeNonC
$LN4@MmFreeNonC:

; 269  : 	}
; 270  : 
; 271  : 	// 검색 후, 해제하고자 하는 메모리 블록의 상태를 FREE로 변경
; 272  : 	dwBlockSize = pCur->block_size;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00033	89 4d f4	 mov	 DWORD PTR _dwBlockSize$[ebp], ecx

; 273  : 	for( i = 0 ; i < dwBlockSize ; i++ )

  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN3@MmFreeNonC
$LN2@MmFreeNonC:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmFreeNonC:
  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004b	3b 45 f4	 cmp	 eax, DWORD PTR _dwBlockSize$[ebp]
  0004e	73 1e		 jae	 SHORT $LN1@MmFreeNonC

; 274  : 	{
; 275  : 		pCur->status = MEM_BLK_FREE;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00053	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 276  : 		pCur->block_size = 0;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  0005c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 277  : 		pCur = pCur->pNext;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00066	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00069	89 4d fc	 mov	 DWORD PTR _pCur$[ebp], ecx

; 278  : 	}

  0006c	eb d1		 jmp	 SHORT $LN2@MmFreeNonC
$LN1@MmFreeNonC:

; 279  : 
; 280  : 	m_MemBlkManager.nFreeBlocks += dwBlockSize;

  0006e	a1 08 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+8
  00073	03 45 f4	 add	 eax, DWORD PTR _dwBlockSize$[ebp]
  00076	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 281  : 	m_MemBlkManager.nUsedBlocks -= dwBlockSize;

  0007b	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+4
  00080	2b 45 f4	 sub	 eax, DWORD PTR _dwBlockSize$[ebp]
  00083	a3 04 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, eax

; 282  : 
; 283  : EXIT_CRITICAL_SECTION();

  00088	9d		 popfd
$LN6@MmFreeNonC:

; 284  : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_MmFreeNonCachedMemory ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetDescAddrFromPoolAddr
_TEXT	SEGMENT
_ResultAddr$ = -4					; size = 4
_pPoolAddr$ = 8						; size = 4
_MmpGetDescAddrFromPoolAddr PROC			; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  : 	int ResultAddr;
; 290  : 
; 291  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 292  : 
; 293  : 	// 실제 메모리 블록 주소에서 메모리풀에서 메모리풀의 시작 주소를 뺀 값
; 294  : 	ResultAddr = (int)pPoolAddr - (int)(m_MemBlkManager.pDescEntry);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pPoolAddr$[ebp]
  0000e	2b 05 0c 00 00
	00		 sub	 eax, DWORD PTR _m_MemBlkManager+12
  00014	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 295  : 	
; 296  : 	// 블록 단위로 나누고, 해당 메모리 디스크리터를 찾는다
; 297  : 	ResultAddr = ResultAddr / MEM_BLK_SIZE * sizeof(MEM_BLK_DESC);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]
  0001a	99		 cdq
  0001b	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00021	03 c2		 add	 eax, edx
  00023	c1 f8 09	 sar	 eax, 9
  00026	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00029	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 298  : 	ResultAddr += (int)(m_MemBlkManager.pDescEntry);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]
  0002f	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _m_MemBlkManager+12
  00035	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 299  : 
; 300  : EXIT_CRITICAL_SECTION();

  00038	9d		 popfd

; 301  : 
; 302  : 	return (MEM_BLK_DESC *)ResultAddr;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]

; 303  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_MmpGetDescAddrFromPoolAddr ENDP
_TEXT	ENDS
END
