; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\Develop\HW\leeysos\fdddrv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CI@CCIBJFIN@FddpTurnOffMotor?$CI?$CJ?5returned?5an?5e@ ; `string'
PUBLIC	_FddInitializeDriver
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_PsCreateThread:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_CrtPrintf:PROC
_BSS	SEGMENT
_m_ThreadHandle DD 01H DUP (?)
_m_ProcessHandle DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CI@CCIBJFIN@FddpTurnOffMotor?$CI?$CJ?5returned?5an?5e@
; File c:\develop\hw\leeysos\fdddrv.c
CONST	SEGMENT
??_C@_0CI@CCIBJFIN@FddpTurnOffMotor?$CI?$CJ?5returned?5an?5e@ DB 'FddpTur'
	DB	'nOffMotor() returned an error.', 0aH, 0dH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _FddInitializeDriver
_TEXT	SEGMENT
_FddInitializeDriver PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 60   : 	// 플로피 디스크의 모터를 OFF
; 61   : 	if( !FddpTurnOffMotor() )

  00009	e8 00 00 00 00	 call	 _FddpTurnOffMotor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN3@FddInitial

; 62   : 	{
; 63   : 		DbgPrint("FddpTurnOffMotor() returned an error.\n\r");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CCIBJFIN@FddpTurnOffMotor?$CI?$CJ?5returned?5an?5e@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 64   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 55		 jmp	 SHORT $LN4@FddInitial
$LN3@FddInitial:

; 65   : 	}
; 66   : 
; 67   : 	// 플로피 디스크에서 수행해야 할 동작들을 처리하기 위한 프로세스 생성
; 68   : 	if( !PsCreateProcess(&m_ProcessHandle) )

  00023	68 00 00 00 00	 push	 OFFSET _m_ProcessHandle
  00028	e8 00 00 00 00	 call	 _PsCreateProcess
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c0		 test	 eax, eax
  00032	75 04		 jne	 SHORT $LN2@FddInitial

; 69   : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	eb 40		 jmp	 SHORT $LN4@FddInitial
$LN2@FddInitial:

; 70   : 
; 71   : 	// 플로피 디스크에서 수행해야 할 동작들을 처리하기 위한 쓰레드 생성
; 72   : 	if( !PsCreateThread(&m_ThreadHandle, m_ProcessHandle, FddpJobProcessThread, NULL, DEFAULT_STACK_SIZE, FALSE, HIGH) )

  00038	6a 02		 push	 2
  0003a	6a 00		 push	 0
  0003c	68 00 00 01 00	 push	 65536			; 00010000H
  00041	6a 00		 push	 0
  00043	68 00 00 00 00	 push	 OFFSET _FddpJobProcessThread
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ProcessHandle
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET _m_ThreadHandle
  00053	e8 00 00 00 00	 call	 _PsCreateThread
  00058	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005b	85 c0		 test	 eax, eax
  0005d	75 04		 jne	 SHORT $LN1@FddInitial

; 73   : 		return FALSE;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 15		 jmp	 SHORT $LN4@FddInitial
$LN1@FddInitial:

; 74   : 
; 75   : 	PsSetThreadStatus(m_ThreadHandle, THREAD_STATUS_READY);

  00063	6a 02		 push	 2
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ThreadHandle
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _PsSetThreadStatus
  00070	83 c4 08	 add	 esp, 8

; 76   : 
; 77   : 	return TRUE;

  00073	b8 01 00 00 00	 mov	 eax, 1
$LN4@FddInitial:

; 78   : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_FddInitializeDriver ENDP
_TEXT	ENDS
PUBLIC	_Fdd_IRQ_Handler
; Function compile flags: /Odtp /ZI
;	COMDAT _Fdd_IRQ_Handler
_TEXT	SEGMENT
_Fdd_IRQ_Handler PROC					; COMDAT

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 83   : 
; 84   : 	
; 85   : 		///////////내용 작성해 주세요///////////////////////
; 86   : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_Fdd_IRQ_Handler ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpTurnOffMotor
_TEXT	SEGMENT
_FddpTurnOffMotor PROC					; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 104  : 	WRITE_PORT_UCHAR((PUCHAR)FDD_DOR_PORT, 0x00);

  00009	6a 00		 push	 0
  0000b	68 f2 03 00 00	 push	 1010			; 000003f2H
  00010	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00015	83 c4 08	 add	 esp, 8

; 105  : 
; 106  : 	return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 107  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_FddpTurnOffMotor ENDP
_TEXT	ENDS
EXTRN	_HalTaskSwitch:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpJobProcessThread
_TEXT	SEGMENT
_job_item$ = -16					; size = 15
_StartContext$ = 8					; size = 4
_FddpJobProcessThread PROC				; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN3@FddpJobPro:

; 241  : 
; 242  : 	FDD_JOB_ITEM job_item;
; 243  : 
; 244  : 	while( 1 )

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 40		 je	 SHORT $LN2@FddpJobPro

; 245  : 	{
; 246  : 		if( !FddpPopJobItem(&job_item) )

  00012	8d 45 f0	 lea	 eax, DWORD PTR _job_item$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _FddpPopJobItem
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN1@FddpJobPro

; 247  : 		{
; 248  : 			HalTaskSwitch();

  00022	e8 00 00 00 00	 call	 _HalTaskSwitch

; 249  : 			continue;

  00027	eb e0		 jmp	 SHORT $LN3@FddpJobPro
$LN1@FddpJobPro:

; 250  : 		}
; 251  : 
; 252  : 		FddpReadWriteSector(job_item.type, job_item.sector, job_item.numbers_of_sectors, job_item.pt_data);

  00029	8b 45 f7	 mov	 eax, DWORD PTR _job_item$[ebp+7]
  0002c	50		 push	 eax
  0002d	8a 4d f6	 mov	 cl, BYTE PTR _job_item$[ebp+6]
  00030	51		 push	 ecx
  00031	66 8b 55 f4	 mov	 dx, WORD PTR _job_item$[ebp+4]
  00035	52		 push	 edx
  00036	8b 45 f0	 mov	 eax, DWORD PTR _job_item$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _FddpReadWriteSector
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 253  : 		PsSetThreadStatus(job_item.thread, THREAD_STATUS_READY);

  00042	6a 02		 push	 2
  00044	8b 45 fb	 mov	 eax, DWORD PTR _job_item$[ebp+11]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _PsSetThreadStatus
  0004d	83 c4 08	 add	 esp, 8

; 254  : 	}

  00050	eb b7		 jmp	 SHORT $LN3@FddpJobPro
$LN2@FddpJobPro:

; 255  : 
; 256  : 	return 0;

  00052	33 c0		 xor	 eax, eax

; 257  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_FddpJobProcessThread ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_FddInterruptOccurred DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _FddpReadWriteSector
_TEXT	SEGMENT
_i$ = -12						; size = 4
_sector$ = -8						; size = 1
_track$ = -7						; size = 1
_head$ = -6						; size = 1
_drive$ = -5						; size = 1
_pDMAAddr$ = -4						; size = 4
_JobType$ = 8						; size = 4
_Sector$ = 12						; size = 2
_NumbersOfSectors$ = 16					; size = 1
_pData$ = 20						; size = 4
_FddpReadWriteSector PROC				; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 166  : 	BYTE *pDMAAddr = (BYTE *)0x00000000;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDMAAddr$[ebp], 0

; 167  : 	BYTE drive, head, track, sector;
; 168  : 
; 169  : 	int i;
; 170  : 
; 171  : 	// 디스크에 쓰기는 구현 X
; 172  : 	if( JobType == FDD_WRITE_SECTOR )

  00010	83 7d 08 01	 cmp	 DWORD PTR _JobType$[ebp], 1
  00014	75 07		 jne	 SHORT $LN13@FddpReadWr

; 173  : 		return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	e9 9f 01 00 00	 jmp	 $LN14@FddpReadWr
$LN13@FddpReadWr:

; 174  : 
; 175  : 	drive	= 0;

  0001d	c6 45 fb 00	 mov	 BYTE PTR _drive$[ebp], 0

; 176  : 	head	= ((Sector % (SECTORS_PER_TRACK * 2)) / SECTORS_PER_TRACK);

  00021	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  00025	99		 cdq
  00026	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0002b	f7 f9		 idiv	 ecx
  0002d	8b c2		 mov	 eax, edx
  0002f	99		 cdq
  00030	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00035	f7 f9		 idiv	 ecx
  00037	88 45 fa	 mov	 BYTE PTR _head$[ebp], al

; 177  : 	track	= (Sector / (SECTORS_PER_TRACK * 2));

  0003a	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  0003e	99		 cdq
  0003f	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00044	f7 f9		 idiv	 ecx
  00046	88 45 f9	 mov	 BYTE PTR _track$[ebp], al

; 178  : 	sector	= (Sector % SECTORS_PER_TRACK) + 1;

  00049	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  0004d	99		 cdq
  0004e	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00053	f7 f9		 idiv	 ecx
  00055	83 c2 01	 add	 edx, 1
  00058	88 55 f8	 mov	 BYTE PTR _sector$[ebp], dl

; 179  : 
; 180  : 	// 모터 ON - 1st Interrupt
; 181  : 	m_FddInterruptOccurred = FALSE;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 182  : 	{
; 183  : 		FddpTurnOnMotor();

  00065	e8 00 00 00 00	 call	 _FddpTurnOnMotor
$LN12@FddpReadWr:

; 184  : 	}
; 185  : 	while( !m_FddInterruptOccurred );

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  00071	75 02		 jne	 SHORT $LN11@FddpReadWr
  00073	eb f5		 jmp	 SHORT $LN12@FddpReadWr
$LN11@FddpReadWr:

; 186  : 
; 187  : 	// calibrate drive - 2st INTERRUPT
; 188  : 	m_FddInterruptOccurred = FALSE;

  00075	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 189  : 	{
; 190  : 		FddpWriteFdcData(0x07);	// calibrate command

  0007f	6a 07		 push	 7
  00081	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00086	83 c4 04	 add	 esp, 4

; 191  : 		FddpWriteFdcData(0x07);	// drive 선택(00 : A, 01 : B, 10 : C, 11 : D)

  00089	6a 07		 push	 7
  0008b	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00090	83 c4 04	 add	 esp, 4
$LN10@FddpReadWr:

; 192  : 	}
; 193  : 	while( !m_FddInterruptOccurred );

  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  0009a	75 02		 jne	 SHORT $LN9@FddpReadWr
  0009c	eb f5		 jmp	 SHORT $LN10@FddpReadWr
$LN9@FddpReadWr:

; 194  : 
; 195  : 	// seek - 3st INTERRUPT
; 196  : 	m_FddInterruptOccurred = FALSE;

  0009e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 197  : 	{
; 198  : 		FddpWriteFdcData(0x0f);					// seek command

  000a8	6a 0f		 push	 15			; 0000000fH
  000aa	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000af	83 c4 04	 add	 esp, 4

; 199  : 		FddpWriteFdcData((head << 2) + drive);	// Head Number

  000b2	0f b6 45 fa	 movzx	 eax, BYTE PTR _head$[ebp]
  000b6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _drive$[ebp]
  000ba	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000c3	83 c4 04	 add	 esp, 4

; 200  : 		FddpWriteFdcData(track);				// Disk의 Head를 위치 시킬 트랙번호

  000c6	8a 45 f9	 mov	 al, BYTE PTR _track$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000cf	83 c4 04	 add	 esp, 4
$LN8@FddpReadWr:

; 201  : 	}
; 202  : 	while( !m_FddInterruptOccurred );

  000d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  000d9	75 02		 jne	 SHORT $LN7@FddpReadWr
  000db	eb f5		 jmp	 SHORT $LN8@FddpReadWr
$LN7@FddpReadWr:

; 203  : 
; 204  : 	// DMA를 설정하는 함수
; 205  : 	FddpSetupDMA(JobType);

  000dd	8b 45 08	 mov	 eax, DWORD PTR _JobType$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _FddpSetupDMA
  000e6	83 c4 04	 add	 esp, 4

; 206  : 
; 207  : 	m_FddInterruptOccurred = FALSE;

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 208  : 	{
; 209  : 		FddpWriteFdcData(0xe6);

  000f3	68 e6 00 00 00	 push	 230			; 000000e6H
  000f8	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000fd	83 c4 04	 add	 esp, 4

; 210  : 		FddpWriteFdcData((head << 2) + drive);

  00100	0f b6 45 fa	 movzx	 eax, BYTE PTR _head$[ebp]
  00104	0f b6 4d fb	 movzx	 ecx, BYTE PTR _drive$[ebp]
  00108	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00111	83 c4 04	 add	 esp, 4

; 211  : 		FddpWriteFdcData(track);

  00114	8a 45 f9	 mov	 al, BYTE PTR _track$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0011d	83 c4 04	 add	 esp, 4

; 212  : 		FddpWriteFdcData(head);

  00120	8a 45 fa	 mov	 al, BYTE PTR _head$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00129	83 c4 04	 add	 esp, 4

; 213  : 		FddpWriteFdcData(1);

  0012c	6a 01		 push	 1
  0012e	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00133	83 c4 04	 add	 esp, 4

; 214  : 		FddpWriteFdcData(2);

  00136	6a 02		 push	 2
  00138	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0013d	83 c4 04	 add	 esp, 4

; 215  : 		FddpWriteFdcData(SECTORS_PER_TRACK);

  00140	6a 12		 push	 18			; 00000012H
  00142	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00147	83 c4 04	 add	 esp, 4

; 216  : 		FddpWriteFdcData(27);

  0014a	6a 1b		 push	 27			; 0000001bH
  0014c	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00151	83 c4 04	 add	 esp, 4

; 217  : 		FddpWriteFdcData(0xff);				

  00154	68 ff 00 00 00	 push	 255			; 000000ffH
  00159	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0015e	83 c4 04	 add	 esp, 4
$LN6@FddpReadWr:

; 218  : 	}
; 219  : 	while( !m_FddInterruptOccurred );

  00161	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  00168	75 02		 jne	 SHORT $LN5@FddpReadWr
  0016a	eb f5		 jmp	 SHORT $LN6@FddpReadWr
$LN5@FddpReadWr:

; 220  : 
; 221  : 	pDMAAddr += (BYTES_PER_SECTOR * (sector - 1));

  0016c	0f b6 45 f8	 movzx	 eax, BYTE PTR _sector$[ebp]
  00170	83 e8 01	 sub	 eax, 1
  00173	c1 e0 09	 shl	 eax, 9
  00176	03 45 fc	 add	 eax, DWORD PTR _pDMAAddr$[ebp]
  00179	89 45 fc	 mov	 DWORD PTR _pDMAAddr$[ebp], eax

; 222  : 
; 223  : 	if( JobType == FDD_READ_SECTOR )

  0017c	83 7d 08 00	 cmp	 DWORD PTR _JobType$[ebp], 0
  00180	75 30		 jne	 SHORT $LN4@FddpReadWr

; 224  : 	{
; 225  : 		for( i = 0 ; i < (BYTES_PER_SECTOR * NumbersOfSectors) ; i++ )

  00182	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00189	eb 09		 jmp	 SHORT $LN3@FddpReadWr
$LN2@FddpReadWr:
  0018b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0018e	83 c0 01	 add	 eax, 1
  00191	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@FddpReadWr:
  00194	0f b6 45 10	 movzx	 eax, BYTE PTR _NumbersOfSectors$[ebp]
  00198	c1 e0 09	 shl	 eax, 9
  0019b	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  0019e	7d 12		 jge	 SHORT $LN4@FddpReadWr

; 226  : 		{
; 227  : 			*(pData + i ) = *(pDMAAddr + i);

  001a0	8b 45 14	 mov	 eax, DWORD PTR _pData$[ebp]
  001a3	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR _pDMAAddr$[ebp]
  001a9	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  001ac	8a 11		 mov	 dl, BYTE PTR [ecx]
  001ae	88 10		 mov	 BYTE PTR [eax], dl

; 228  : 		}

  001b0	eb d9		 jmp	 SHORT $LN2@FddpReadWr
$LN4@FddpReadWr:

; 229  : 	}
; 230  : 
; 231  : 	// 모터 OFF
; 232  : 	FddpTurnOffMotor();

  001b2	e8 00 00 00 00	 call	 _FddpTurnOffMotor

; 233  : 
; 234  : 	return TRUE;

  001b7	b8 01 00 00 00	 mov	 eax, 1
$LN14@FddpReadWr:

; 235  : 
; 236  : }

  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_FddpReadWriteSector ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpTurnOnMotor
_TEXT	SEGMENT
_FddpTurnOnMotor PROC					; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	// Drive A, DMA 활성화, RESET, A드라이브 모터 가동
; 96   : 	WRITE_PORT_UCHAR((PUCHAR)FDD_DOR_PORT, 0x1c);	// Drive A, DMA 활성화, RESET, A 드라이브 모터 가동

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	68 f2 03 00 00	 push	 1010			; 000003f2H
  00010	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00015	83 c4 08	 add	 esp, 8

; 97   : 
; 98   : 	return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 99   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_FddpTurnOnMotor ENDP
_TEXT	ENDS
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpWriteFdcData
_TEXT	SEGMENT
_status$ = -1						; size = 1
_Data$ = 8						; size = 1
_FddpWriteFdcData PROC					; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN3@FddpWriteF:

; 113  : 	UCHAR status;
; 114  : 
; 115  : 	do
; 116  : 	{
; 117  : 		status = READ_PORT_UCHAR((PUCHAR)FDD_STATUS_PORT);

  00009	68 f4 03 00 00	 push	 1012			; 000003f4H
  0000e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00013	83 c4 04	 add	 esp, 4
  00016	88 45 ff	 mov	 BYTE PTR _status$[ebp], al

; 118  : 	}
; 119  : 	while( (status & 0xc0) != 0x80 );

  00019	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0001d	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00022	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00027	75 e0		 jne	 SHORT $LN3@FddpWriteF

; 120  : 	WRITE_PORT_UCHAR((PUCHAR)FDD_DATA_PORT, Data);

  00029	8a 45 08	 mov	 al, BYTE PTR _Data$[ebp]
  0002c	50		 push	 eax
  0002d	68 f5 03 00 00	 push	 1013			; 000003f5H
  00032	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00037	83 c4 08	 add	 esp, 8

; 121  : 
; 122  : 	return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1

; 123  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_FddpWriteFdcData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpSetupDMA
_TEXT	SEGMENT
_count$ = -4						; size = 2
_JobType$ = 8						; size = 4
_FddpSetupDMA PROC					; COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 142  : 	WORD count = BYTES_PER_SECTOR * SECTORS_PER_TRACK - 1;

  00009	66 c7 45 fc ff
	23		 mov	 WORD PTR _count$[ebp], 9215 ; 000023ffH

; 143  : 
; 144  : 	// 읽기 모드인지 쓰기 모드인지 설정
; 145  : 	if( JobType == FDD_READ_SECTOR )

  0000f	83 7d 08 00	 cmp	 DWORD PTR _JobType$[ebp], 0
  00013	75 0e		 jne	 SHORT $LN2@FddpSetupD

; 146  : 		WRITE_PORT_UCHAR((PUCHAR)0x0b, 0x46);	// single mode, WRITE, Channel 2

  00015	6a 46		 push	 70			; 00000046H
  00017	6a 0b		 push	 11			; 0000000bH
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 147  : 	else

  00021	eb 0c		 jmp	 SHORT $LN1@FddpSetupD
$LN2@FddpSetupD:

; 148  : 		WRITE_PORT_UCHAR((PUCHAR)0x0b, 0x4a);	// single mode, READ, Channel 2

  00023	6a 4a		 push	 74			; 0000004aH
  00025	6a 0b		 push	 11			; 0000000bH
  00027	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002c	83 c4 08	 add	 esp, 8
$LN1@FddpSetupD:

; 149  : 
; 150  : 	// ADDRESS
; 151  : 	WRITE_PORT_UCHAR((PUCHAR)0x04, 0x00);	// address register에 플로피에서 읽은 데이터를 저장해야할 주소 입력

  0002f	6a 00		 push	 0
  00031	6a 04		 push	 4
  00033	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00038	83 c4 08	 add	 esp, 8

; 152  : 	WRITE_PORT_UCHAR((PUCHAR)0x04, 0x00);	

  0003b	6a 00		 push	 0
  0003d	6a 04		 push	 4
  0003f	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00044	83 c4 08	 add	 esp, 8

; 153  : 	WRITE_PORT_UCHAR((PUCHAR)0x81, 0x00);	// Channel 2를 사용하기 위한 명령어

  00047	6a 00		 push	 0
  00049	68 81 00 00 00	 push	 129			; 00000081H
  0004e	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00053	83 c4 08	 add	 esp, 8

; 154  : 
; 155  : 	WRITE_PORT_UCHAR((PUCHAR)0x05, (BYTE)count);		// count register에 데이터의 크기를 입력

  00056	8a 45 fc	 mov	 al, BYTE PTR _count$[ebp]
  00059	50		 push	 eax
  0005a	6a 05		 push	 5
  0005c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00061	83 c4 08	 add	 esp, 8

; 156  : 	WRITE_PORT_UCHAR((PUCHAR)0x05, (BYTE)(count >> 8));	

  00064	0f b7 45 fc	 movzx	 eax, WORD PTR _count$[ebp]
  00068	c1 f8 08	 sar	 eax, 8
  0006b	50		 push	 eax
  0006c	6a 05		 push	 5
  0006e	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00073	83 c4 08	 add	 esp, 8

; 157  : 
; 158  : 	WRITE_PORT_UCHAR((PUCHAR)0x0a, 0x02);	// channel mask register에 channel 2번 활성화

  00076	6a 02		 push	 2
  00078	6a 0a		 push	 10			; 0000000aH
  0007a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007f	83 c4 08	 add	 esp, 8

; 159  : 
; 160  : 	return TRUE;

  00082	b8 01 00 00 00	 mov	 eax, 1

; 161  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_FddpSetupDMA ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_JobItemQ DB	01e3H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _FddpPopJobItem
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pJobItem$ = 8						; size = 4
_FddpPopJobItem PROC					; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 262  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 263  : 
; 264  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 265  : 	{
; 266  : 		// 큐 관리 함수로 부터 카운트 확인
; 267  : 		if( m_JobItemQ.cnt == 0 )

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ
  00019	85 c0		 test	 eax, eax
  0001b	75 0c		 jne	 SHORT $LN2@FddpPopJob

; 268  : 		{
; 269  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 270  : 			goto $exit;

  00024	e9 9a 00 00 00	 jmp	 $$exit$1007
$LN2@FddpPopJob:

; 271  : 		}
; 272  : 
; 273  : 		m_JobItemQ.cnt--;

  00029	a0 00 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ
  0002e	2c 01		 sub	 al, 1
  00030	a2 00 00 00 00	 mov	 BYTE PTR _m_JobItemQ, al

; 274  : 		pJobItem->type					= m_JobItemQ.queue[m_JobItemQ.head].type;

  00035	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  0003c	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00042	8b 90 03 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+3]
  00048	89 11		 mov	 DWORD PTR [ecx], edx

; 275  : 		pJobItem->sector				= m_JobItemQ.queue[m_JobItemQ.head].sector;

  0004a	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00051	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00057	66 8b 90 07 00
	00 00		 mov	 dx, WORD PTR _m_JobItemQ[eax+7]
  0005e	66 89 51 04	 mov	 WORD PTR [ecx+4], dx

; 276  : 		pJobItem->numbers_of_sectors	= m_JobItemQ.queue[m_JobItemQ.head].numbers_of_sectors;

  00062	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00069	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0006f	8a 90 09 00 00
	00		 mov	 dl, BYTE PTR _m_JobItemQ[eax+9]
  00075	88 51 06	 mov	 BYTE PTR [ecx+6], dl

; 277  : 		pJobItem->pt_data				= m_JobItemQ.queue[m_JobItemQ.head].pt_data;

  00078	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  0007f	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00085	8b 90 0a 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+10]
  0008b	89 51 07	 mov	 DWORD PTR [ecx+7], edx

; 278  : 		pJobItem->thread				= m_JobItemQ.queue[m_JobItemQ.head].thread;

  0008e	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00095	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0009b	8b 90 0e 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+14]
  000a1	89 51 0b	 mov	 DWORD PTR [ecx+11], edx

; 279  : 		m_JobItemQ.head++;

  000a4	a0 01 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ+1
  000a9	04 01		 add	 al, 1
  000ab	a2 01 00 00 00	 mov	 BYTE PTR _m_JobItemQ+1, al

; 280  : 		if( m_JobItemQ.head >= FDD_JOB_ITEM_Q_SIZE )

  000b0	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  000b7	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ba	7c 07		 jl	 SHORT $$exit$1007

; 281  : 			m_JobItemQ.head = 0;

  000bc	c6 05 01 00 00
	00 00		 mov	 BYTE PTR _m_JobItemQ+1, 0
$$exit$1007:

; 282  : 	}
; 283  : $exit:
; 284  : EXIT_CRITICAL_SECTION();

  000c3	9d		 popfd

; 285  : 
; 286  : 	return bResult;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 287  : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_FddpPopJobItem ENDP
_TEXT	ENDS
END
