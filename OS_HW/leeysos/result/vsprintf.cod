; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\Develop\HW\leeysos\vsprintf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vsprintf
; Function compile flags: /Odtp /ZI
; File c:\develop\hw\leeysos\vsprintf.c
;	COMDAT _vsprintf
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 21   : 	return ffmt(buf, fmt, args);

  00009	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _ffmt
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_vsprintf ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _ffmt
_TEXT	SEGMENT
tv81 = -136						; size = 4
_width$ = -68						; size = 4
_flag$ = -64						; size = 4
_base$ = -60						; size = 4
_number$ = -56						; size = 4
_prefix$ = -49						; size = 1
_numptr$ = -48						; size = 4
_numtemp$ = -44						; size = 33
_temp$ = -5						; size = 1
_str$ = -4						; size = 4
_buf$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
_ffmt	PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 27   : 	char *str, temp, numtemp[33], *numptr, prefix;
; 28   : 	unsigned int number, base, flag, width;
; 29   : 
; 30   : 	str = buf;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 31   : 	numtemp[32] = 0;

  00012	c6 45 f4 00	 mov	 BYTE PTR _numtemp$[ebp+32], 0
  00016	eb 09		 jmp	 SHORT $LN35@ffmt
$LN34@ffmt:

; 32   : 
; 33   : 	for( ; *fmt ; fmt++ )

  00018	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 0c	 mov	 DWORD PTR _fmt$[ebp], eax
$LN35@ffmt:
  00021	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00027	85 c9		 test	 ecx, ecx
  00029	0f 84 b3 02 00
	00		 je	 $LN33@ffmt

; 34   : 	{
; 35   : 		/* normal character */
; 36   : 
; 37   : 		if( *fmt != '%' )

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 25	 cmp	 ecx, 37			; 00000025H
  00038	74 15		 je	 SHORT $LN32@ffmt

; 38   : 		{
; 39   : 			*str = *fmt;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00040	8a 11		 mov	 dl, BYTE PTR [ecx]
  00042	88 10		 mov	 BYTE PTR [eax], dl

; 40   : 			++str;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 41   : 
; 42   : 			continue;

  0004d	eb c9		 jmp	 SHORT $LN34@ffmt
$LN32@ffmt:

; 43   : 		}
; 44   : 
; 45   : 		/* flag process */
; 46   : 		fmt++;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	89 45 0c	 mov	 DWORD PTR _fmt$[ebp], eax

; 47   : 		flag = 0;

  00058	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 48   : 		prefix = ' ';

  0005f	c6 45 cf 20	 mov	 BYTE PTR _prefix$[ebp], 32 ; 00000020H

; 49   : 		width = 0;

  00063	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _width$[ebp], 0

; 50   : 
; 51   : 		if( *fmt == '0' )

  0006a	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0006d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00070	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00073	75 04		 jne	 SHORT $LN30@ffmt

; 52   : 			prefix = '0';

  00075	c6 45 cf 30	 mov	 BYTE PTR _prefix$[ebp], 48 ; 00000030H
$LN30@ffmt:

; 53   : 
; 54   : 		while( *fmt >= '0' && *fmt <= '9' )

  00079	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0007c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007f	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00082	7c 1f		 jl	 SHORT $LN29@ffmt
  00084	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00087	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008a	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0008d	7f 14		 jg	 SHORT $LN29@ffmt

; 55   : 		{
; 56   : 			width++;

  0008f	8b 45 bc	 mov	 eax, DWORD PTR _width$[ebp]
  00092	83 c0 01	 add	 eax, 1
  00095	89 45 bc	 mov	 DWORD PTR _width$[ebp], eax

; 57   : 			fmt++;

  00098	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0009b	83 c0 01	 add	 eax, 1
  0009e	89 45 0c	 mov	 DWORD PTR _fmt$[ebp], eax

; 58   : 		}

  000a1	eb d6		 jmp	 SHORT $LN30@ffmt
$LN29@ffmt:

; 59   : 		
; 60   : 		switch( *fmt )

  000a3	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  000a6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a9	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000af	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv81[ebp]
  000b5	83 ea 25	 sub	 edx, 37			; 00000025H
  000b8	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
  000be	83 bd 78 ff ff
	ff 53		 cmp	 DWORD PTR tv81[ebp], 83	; 00000053H
  000c5	0f 87 d4 00 00
	00		 ja	 $LN15@ffmt
  000cb	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  000d1	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN38@ffmt[eax]
  000d8	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN39@ffmt[ecx*4]
$LN26@ffmt:

; 61   : 		{
; 62   : 		case 'c':
; 63   : 			*str++ = va_arg(args, char);

  000df	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 10	 mov	 DWORD PTR _args$[ebp], eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  000eb	8b 55 10	 mov	 edx, DWORD PTR _args$[ebp]
  000ee	8a 42 fc	 mov	 al, BYTE PTR [edx-4]
  000f1	88 01		 mov	 BYTE PTR [ecx], al
  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  000f6	83 c1 01	 add	 ecx, 1
  000f9	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx

; 64   : 			continue;

  000fc	e9 17 ff ff ff	 jmp	 $LN34@ffmt
$LN25@ffmt:

; 65   : 		case 's':
; 66   : 			numptr = va_arg(args, char *);

  00101	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  00104	83 c0 04	 add	 eax, 4
  00107	89 45 10	 mov	 DWORD PTR _args$[ebp], eax
  0010a	8b 4d 10	 mov	 ecx, DWORD PTR _args$[ebp]
  0010d	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00110	89 55 d0	 mov	 DWORD PTR _numptr$[ebp], edx
$LN24@ffmt:

; 67   : 			while ( *numptr != 0 )

  00113	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  00116	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00119	85 c9		 test	 ecx, ecx
  0011b	74 1e		 je	 SHORT $LN23@ffmt

; 68   : 				*str++ = *numptr++;

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00120	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  00123	8a 11		 mov	 dl, BYTE PTR [ecx]
  00125	88 10		 mov	 BYTE PTR [eax], dl
  00127	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0012a	83 c0 01	 add	 eax, 1
  0012d	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax
  00130	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  00133	83 c1 01	 add	 ecx, 1
  00136	89 4d d0	 mov	 DWORD PTR _numptr$[ebp], ecx
  00139	eb d8		 jmp	 SHORT $LN24@ffmt
$LN23@ffmt:

; 69   : 			continue;

  0013b	e9 d8 fe ff ff	 jmp	 $LN34@ffmt
$LN22@ffmt:

; 70   : 		case '%':
; 71   : 			*str++ = '%';

  00140	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00143	c6 00 25	 mov	 BYTE PTR [eax], 37	; 00000025H
  00146	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  00149	83 c1 01	 add	 ecx, 1
  0014c	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx

; 72   : 			continue;

  0014f	e9 c4 fe ff ff	 jmp	 $LN34@ffmt
$LN21@ffmt:

; 73   : 		case 'b':
; 74   : 			base = 2;

  00154	c7 45 c4 02 00
	00 00		 mov	 DWORD PTR _base$[ebp], 2

; 75   : 			continue;

  0015b	e9 b8 fe ff ff	 jmp	 $LN34@ffmt
$LN20@ffmt:

; 76   : 		case 'd': case 'i':
; 77   : 			base = 10;

  00160	c7 45 c4 0a 00
	00 00		 mov	 DWORD PTR _base$[ebp], 10 ; 0000000aH

; 78   : 			flag |= SIGN;

  00167	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  0016a	83 c8 01	 or	 eax, 1
  0016d	89 45 c0	 mov	 DWORD PTR _flag$[ebp], eax

; 79   : 			break;

  00170	eb 32		 jmp	 SHORT $LN27@ffmt
$LN19@ffmt:

; 80   : 		case 'u':
; 81   : 			base = 10;

  00172	c7 45 c4 0a 00
	00 00		 mov	 DWORD PTR _base$[ebp], 10 ; 0000000aH

; 82   : 			break;

  00179	eb 29		 jmp	 SHORT $LN27@ffmt
$LN18@ffmt:

; 83   : 		case 'o':
; 84   : 			base = 8;

  0017b	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR _base$[ebp], 8

; 85   : 			break;

  00182	eb 20		 jmp	 SHORT $LN27@ffmt
$LN17@ffmt:

; 86   : 		case 'X':
; 87   : 			base = 16;

  00184	c7 45 c4 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H

; 88   : 			flag |= LARGE;

  0018b	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  0018e	83 c8 02	 or	 eax, 2
  00191	89 45 c0	 mov	 DWORD PTR _flag$[ebp], eax

; 89   : 			break;

  00194	eb 0e		 jmp	 SHORT $LN27@ffmt
$LN16@ffmt:

; 90   : 		case 'x':
; 91   : 			base = 16;

  00196	c7 45 c4 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H

; 92   : 			break;

  0019d	eb 05		 jmp	 SHORT $LN27@ffmt
$LN15@ffmt:

; 93   : 		default:
; 94   : 			continue;

  0019f	e9 74 fe ff ff	 jmp	 $LN34@ffmt
$LN27@ffmt:

; 95   : 		}
; 96   : 		
; 97   : 		/* number */
; 98   : 		numptr = &numtemp[31];

  001a4	8d 45 f3	 lea	 eax, DWORD PTR _numtemp$[ebp+31]
  001a7	89 45 d0	 mov	 DWORD PTR _numptr$[ebp], eax

; 99   : 		number = va_arg(args, unsigned int);

  001aa	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  001ad	83 c0 04	 add	 eax, 4
  001b0	89 45 10	 mov	 DWORD PTR _args$[ebp], eax
  001b3	8b 4d 10	 mov	 ecx, DWORD PTR _args$[ebp]
  001b6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  001b9	89 55 c8	 mov	 DWORD PTR _number$[ebp], edx

; 100  : 
; 101  : 		if( (flag & SIGN ) && (number & 0x80000000 ) )

  001bc	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  001bf	83 e0 01	 and	 eax, 1
  001c2	74 24		 je	 SHORT $LN13@ffmt
  001c4	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  001c7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001cc	74 1a		 je	 SHORT $LN13@ffmt

; 102  : 		{
; 103  : 			number = ~number + 1;	/* 2's complement */

  001ce	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  001d1	f7 d0		 not	 eax
  001d3	83 c0 01	 add	 eax, 1
  001d6	89 45 c8	 mov	 DWORD PTR _number$[ebp], eax

; 104  : 			*str++ = '-';			/* '-'[NUM] */

  001d9	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  001dc	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
  001df	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  001e2	83 c1 01	 add	 ecx, 1
  001e5	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx
$LN13@ffmt:

; 105  : 		}
; 106  : 
; 107  : 		do 
; 108  : 		{
; 109  : 			temp = number % base;

  001e8	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  001eb	33 d2		 xor	 edx, edx
  001ed	f7 75 c4	 div	 DWORD PTR _base$[ebp]
  001f0	88 55 fb	 mov	 BYTE PTR _temp$[ebp], dl

; 110  : 
; 111  : 			if( temp > 9 )

  001f3	0f be 45 fb	 movsx	 eax, BYTE PTR _temp$[ebp]
  001f7	83 f8 09	 cmp	 eax, 9
  001fa	7e 1d		 jle	 SHORT $LN10@ffmt

; 112  : 				temp += ( ( flag & LARGE ? 'A' : 'a' ) - 10 );

  001fc	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  001ff	83 e0 02	 and	 eax, 2
  00202	f7 d8		 neg	 eax
  00204	1b c0		 sbb	 eax, eax
  00206	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00209	83 c0 61	 add	 eax, 97			; 00000061H
  0020c	0f be 4d fb	 movsx	 ecx, BYTE PTR _temp$[ebp]
  00210	8d 54 01 f6	 lea	 edx, DWORD PTR [ecx+eax-10]
  00214	88 55 fb	 mov	 BYTE PTR _temp$[ebp], dl

; 113  : 			else

  00217	eb 0a		 jmp	 SHORT $LN9@ffmt
$LN10@ffmt:

; 114  : 				temp += '0';

  00219	0f be 45 fb	 movsx	 eax, BYTE PTR _temp$[ebp]
  0021d	83 c0 30	 add	 eax, 48			; 00000030H
  00220	88 45 fb	 mov	 BYTE PTR _temp$[ebp], al
$LN9@ffmt:

; 115  : 
; 116  : 			*numptr-- = temp;

  00223	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  00226	8a 4d fb	 mov	 cl, BYTE PTR _temp$[ebp]
  00229	88 08		 mov	 BYTE PTR [eax], cl
  0022b	8b 55 d0	 mov	 edx, DWORD PTR _numptr$[ebp]
  0022e	83 ea 01	 sub	 edx, 1
  00231	89 55 d0	 mov	 DWORD PTR _numptr$[ebp], edx

; 117  : 
; 118  : 			if( width > 0 )

  00234	83 7d bc 00	 cmp	 DWORD PTR _width$[ebp], 0
  00238	76 09		 jbe	 SHORT $LN12@ffmt

; 119  : 				width--;

  0023a	8b 45 bc	 mov	 eax, DWORD PTR _width$[ebp]
  0023d	83 e8 01	 sub	 eax, 1
  00240	89 45 bc	 mov	 DWORD PTR _width$[ebp], eax
$LN12@ffmt:

; 120  : 		}
; 121  : 		while( number /= base );

  00243	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  00246	33 d2		 xor	 edx, edx
  00248	f7 75 c4	 div	 DWORD PTR _base$[ebp]
  0024b	89 45 c8	 mov	 DWORD PTR _number$[ebp], eax
  0024e	83 7d c8 00	 cmp	 DWORD PTR _number$[ebp], 0
  00252	75 94		 jne	 SHORT $LN13@ffmt

; 122  : 		
; 123  : 		if( width > 0 )

  00254	83 7d bc 00	 cmp	 DWORD PTR _width$[ebp], 0
  00258	76 23		 jbe	 SHORT $LN7@ffmt
$LN6@ffmt:

; 124  : 		{
; 125  : 			while( width-- != 0 )

  0025a	8b 45 bc	 mov	 eax, DWORD PTR _width$[ebp]
  0025d	8b 4d bc	 mov	 ecx, DWORD PTR _width$[ebp]
  00260	83 e9 01	 sub	 ecx, 1
  00263	89 4d bc	 mov	 DWORD PTR _width$[ebp], ecx
  00266	85 c0		 test	 eax, eax
  00268	74 13		 je	 SHORT $LN7@ffmt

; 126  : 				*numptr-- = prefix;

  0026a	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  0026d	8a 4d cf	 mov	 cl, BYTE PTR _prefix$[ebp]
  00270	88 08		 mov	 BYTE PTR [eax], cl
  00272	8b 55 d0	 mov	 edx, DWORD PTR _numptr$[ebp]
  00275	83 ea 01	 sub	 edx, 1
  00278	89 55 d0	 mov	 DWORD PTR _numptr$[ebp], edx
  0027b	eb dd		 jmp	 SHORT $LN6@ffmt
$LN7@ffmt:

; 127  : 		}
; 128  : 
; 129  : 		if( *fmt == 'x' || *fmt == 'X' )

  0027d	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00280	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00283	83 f9 78	 cmp	 ecx, 120		; 00000078H
  00286	74 0b		 je	 SHORT $LN3@ffmt
  00288	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0028b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0028e	83 f9 58	 cmp	 ecx, 88			; 00000058H
  00291	75 1e		 jne	 SHORT $LN2@ffmt
$LN3@ffmt:

; 130  : 		{
; 131  : 			*numptr-- = 'x';

  00293	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  00296	c6 00 78	 mov	 BYTE PTR [eax], 120	; 00000078H
  00299	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  0029c	83 e9 01	 sub	 ecx, 1
  0029f	89 4d d0	 mov	 DWORD PTR _numptr$[ebp], ecx

; 132  : 			*numptr-- = '0';

  002a2	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  002a5	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  002a8	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  002ab	83 e9 01	 sub	 ecx, 1
  002ae	89 4d d0	 mov	 DWORD PTR _numptr$[ebp], ecx
$LN2@ffmt:

; 133  : 		}
; 134  : 
; 135  : 		while( temp = *(++numptr) )

  002b1	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  002b4	83 c0 01	 add	 eax, 1
  002b7	89 45 d0	 mov	 DWORD PTR _numptr$[ebp], eax
  002ba	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  002bd	8a 11		 mov	 dl, BYTE PTR [ecx]
  002bf	88 55 fb	 mov	 BYTE PTR _temp$[ebp], dl
  002c2	0f be 45 fb	 movsx	 eax, BYTE PTR _temp$[ebp]
  002c6	85 c0		 test	 eax, eax
  002c8	74 13		 je	 SHORT $LN1@ffmt

; 136  : 				*str++ = temp;

  002ca	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  002cd	8a 4d fb	 mov	 cl, BYTE PTR _temp$[ebp]
  002d0	88 08		 mov	 BYTE PTR [eax], cl
  002d2	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  002d5	83 c2 01	 add	 edx, 1
  002d8	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx
  002db	eb d4		 jmp	 SHORT $LN2@ffmt
$LN1@ffmt:

; 137  : 	}

  002dd	e9 36 fd ff ff	 jmp	 $LN34@ffmt
$LN33@ffmt:

; 138  : 
; 139  : 	*str = 0;

  002e2	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  002e5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 140  : 
; 141  : 	return (int)(str - buf + 1);

  002e8	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  002eb	2b 45 08	 sub	 eax, DWORD PTR _buf$[ebp]
  002ee	83 c0 01	 add	 eax, 1

; 142  : }

  002f1	5f		 pop	 edi
  002f2	5e		 pop	 esi
  002f3	5b		 pop	 ebx
  002f4	8b e5		 mov	 esp, ebp
  002f6	5d		 pop	 ebp
  002f7	c3		 ret	 0
$LN39@ffmt:
  002f8	00 00 00 00	 DD	 $LN22@ffmt
  002fc	00 00 00 00	 DD	 $LN17@ffmt
  00300	00 00 00 00	 DD	 $LN21@ffmt
  00304	00 00 00 00	 DD	 $LN26@ffmt
  00308	00 00 00 00	 DD	 $LN20@ffmt
  0030c	00 00 00 00	 DD	 $LN18@ffmt
  00310	00 00 00 00	 DD	 $LN25@ffmt
  00314	00 00 00 00	 DD	 $LN19@ffmt
  00318	00 00 00 00	 DD	 $LN16@ffmt
  0031c	00 00 00 00	 DD	 $LN15@ffmt
$LN38@ffmt:
  00320	00		 DB	 0
  00321	09		 DB	 9
  00322	09		 DB	 9
  00323	09		 DB	 9
  00324	09		 DB	 9
  00325	09		 DB	 9
  00326	09		 DB	 9
  00327	09		 DB	 9
  00328	09		 DB	 9
  00329	09		 DB	 9
  0032a	09		 DB	 9
  0032b	09		 DB	 9
  0032c	09		 DB	 9
  0032d	09		 DB	 9
  0032e	09		 DB	 9
  0032f	09		 DB	 9
  00330	09		 DB	 9
  00331	09		 DB	 9
  00332	09		 DB	 9
  00333	09		 DB	 9
  00334	09		 DB	 9
  00335	09		 DB	 9
  00336	09		 DB	 9
  00337	09		 DB	 9
  00338	09		 DB	 9
  00339	09		 DB	 9
  0033a	09		 DB	 9
  0033b	09		 DB	 9
  0033c	09		 DB	 9
  0033d	09		 DB	 9
  0033e	09		 DB	 9
  0033f	09		 DB	 9
  00340	09		 DB	 9
  00341	09		 DB	 9
  00342	09		 DB	 9
  00343	09		 DB	 9
  00344	09		 DB	 9
  00345	09		 DB	 9
  00346	09		 DB	 9
  00347	09		 DB	 9
  00348	09		 DB	 9
  00349	09		 DB	 9
  0034a	09		 DB	 9
  0034b	09		 DB	 9
  0034c	09		 DB	 9
  0034d	09		 DB	 9
  0034e	09		 DB	 9
  0034f	09		 DB	 9
  00350	09		 DB	 9
  00351	09		 DB	 9
  00352	09		 DB	 9
  00353	01		 DB	 1
  00354	09		 DB	 9
  00355	09		 DB	 9
  00356	09		 DB	 9
  00357	09		 DB	 9
  00358	09		 DB	 9
  00359	09		 DB	 9
  0035a	09		 DB	 9
  0035b	09		 DB	 9
  0035c	09		 DB	 9
  0035d	02		 DB	 2
  0035e	03		 DB	 3
  0035f	04		 DB	 4
  00360	09		 DB	 9
  00361	09		 DB	 9
  00362	09		 DB	 9
  00363	09		 DB	 9
  00364	04		 DB	 4
  00365	09		 DB	 9
  00366	09		 DB	 9
  00367	09		 DB	 9
  00368	09		 DB	 9
  00369	09		 DB	 9
  0036a	05		 DB	 5
  0036b	09		 DB	 9
  0036c	09		 DB	 9
  0036d	09		 DB	 9
  0036e	06		 DB	 6
  0036f	09		 DB	 9
  00370	07		 DB	 7
  00371	09		 DB	 9
  00372	09		 DB	 9
  00373	08		 DB	 8
_ffmt	ENDP
_TEXT	ENDS
END
